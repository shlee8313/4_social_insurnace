-- ===============================
-- 4대보험 취득상실 통합 관리 시스템 - 완전 최종 버전
-- (일용직 롤링 월별 판정 및 배치 처리 시스템 포함)
-- 모든 테이블 및 필드 코멘트 포함
-- ===============================

-- ===============================
-- 1. 사용자 관리 시스템
-- ===============================

-- 1-1. 사용자 계정 테이블
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    
    name VARCHAR(50) NOT NULL,
    phone_number VARCHAR(20),
    
    is_active BOOLEAN DEFAULT TRUE,
    is_email_verified BOOLEAN DEFAULT FALSE,
    last_login TIMESTAMP WITH TIME ZONE,
    login_count INTEGER DEFAULT 0,
    
    password_changed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP WITH TIME ZONE,
    
    failed_login_attempts INTEGER DEFAULT 0,
    locked_until TIMESTAMP WITH TIME ZONE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- users 테이블 코멘트
COMMENT ON TABLE users IS '사용자 계정 관리 테이블 (노무사 사무실 직원 및 회사 직원)';
COMMENT ON COLUMN users.user_id IS '사용자 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN users.username IS '로그인 아이디 (영문+숫자, 4-50자, 유니크)';
COMMENT ON COLUMN users.email IS '이메일 주소 (로그인 가능, 유니크, 인증 필요)';
COMMENT ON COLUMN users.password_hash IS '암호화된 비밀번호 (bcrypt 등으로 해시화, 원본 저장 금지)';
COMMENT ON COLUMN users.name IS '실명 (한글 또는 영문, 급여명세서 등에 사용)';
COMMENT ON COLUMN users.phone_number IS '연락처 (휴대폰 번호, 인증 및 연락용)';
COMMENT ON COLUMN users.is_active IS '계정 활성화 여부 (TRUE:활성, FALSE:비활성/정지)';
COMMENT ON COLUMN users.is_email_verified IS '이메일 인증 완료 여부 (TRUE:인증완료, FALSE:미인증)';
COMMENT ON COLUMN users.last_login IS '마지막 로그인 일시 (접속 통계 및 보안 관리용)';
COMMENT ON COLUMN users.login_count IS '총 로그인 횟수 (사용 통계 및 활성도 측정용)';
COMMENT ON COLUMN users.password_changed_at IS '비밀번호 마지막 변경일시 (보안 정책 적용용)';
COMMENT ON COLUMN users.password_reset_token IS '비밀번호 재설정 토큰 (임시 발급, 만료시간 존재)';
COMMENT ON COLUMN users.password_reset_expires IS '비밀번호 재설정 토큰 만료일시';
COMMENT ON COLUMN users.failed_login_attempts IS '연속 로그인 실패 횟수 (계정 잠금 기준, 5회 이상시 잠금)';
COMMENT ON COLUMN users.locked_until IS '계정 잠금 해제 예정 시간 (NULL이면 잠금 없음)';
COMMENT ON COLUMN users.created_at IS '계정 생성일시 (가입일)';
COMMENT ON COLUMN users.updated_at IS '계정 정보 최종 수정일시 (프로필 변경시 자동 업데이트)';

-- 1-2. 역할 정의 테이블
CREATE TABLE roles (
    role_id SERIAL PRIMARY KEY,
    role_code VARCHAR(30) NOT NULL UNIQUE,
    role_name VARCHAR(100) NOT NULL,
    role_category VARCHAR(20) NOT NULL CHECK (role_category IN ('company', 'labor_office')),
    
    permissions JSONB NOT NULL DEFAULT '{}',
    
    description TEXT,
    is_system_role BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- roles 테이블 코멘트
COMMENT ON TABLE roles IS '시스템 역할 정의 테이블 (권한 관리의 핵심)';
COMMENT ON COLUMN roles.role_id IS '역할 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN roles.role_code IS '역할 코드 (LABOR_ADMIN, COMPANY_HR 등, 시스템에서 참조용)';
COMMENT ON COLUMN roles.role_name IS '역할명 (노무사 사무실 관리자, 회사 인사담당자 등, 사용자에게 표시)';
COMMENT ON COLUMN roles.role_category IS '역할 카테고리 (company:회사용, labor_office:노무사사무실용)';
COMMENT ON COLUMN roles.permissions IS '권한 목록 JSON 형태 ({"workers": ["read", "write"], "payroll": ["read"]})';
COMMENT ON COLUMN roles.description IS '역할 상세 설명 (역할의 책임과 권한 범위 설명)';
COMMENT ON COLUMN roles.is_system_role IS '시스템 기본 역할 여부 (TRUE:시스템기본, FALSE:사용자정의)';
COMMENT ON COLUMN roles.is_active IS '역할 사용 여부 (TRUE:사용, FALSE:사용안함, 삭제 대신 비활성화)';
COMMENT ON COLUMN roles.created_at IS '역할 생성일시';

-- 1-3. 사용자 역할 매핑 테이블
CREATE TABLE user_roles (
    user_role_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    role_id INTEGER NOT NULL REFERENCES roles(role_id),
    
    scope_type VARCHAR(20) CHECK (scope_type IN ('global', 'company', 'department', 'labor_office')),
    scope_company_id INTEGER,
    scope_department_id INTEGER,
    scope_labor_office_id INTEGER,
    
    start_date DATE NOT NULL DEFAULT CURRENT_DATE,
    end_date DATE,
    
    is_active BOOLEAN DEFAULT TRUE,
    assigned_by INTEGER REFERENCES users(user_id),
    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(user_id, role_id, scope_type, scope_company_id, scope_department_id, scope_labor_office_id)
);

-- user_roles 테이블 코멘트
COMMENT ON TABLE user_roles IS '사용자별 역할 배정 테이블 (범위별 권한 설정 지원)';
COMMENT ON COLUMN user_roles.user_role_id IS '사용자 역할 배정 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN user_roles.user_id IS '사용자 ID (users 테이블 외래키, 계정 삭제시 함께 삭제)';
COMMENT ON COLUMN user_roles.role_id IS '역할 ID (roles 테이블 외래키)';
COMMENT ON COLUMN user_roles.scope_type IS '권한 범위 유형 (global:전체, company:회사별, department:부서별, labor_office:노무사사무실별)';
COMMENT ON COLUMN user_roles.scope_company_id IS '권한 범위 회사 ID (해당 회사에서만 권한 유효, NULL이면 전체)';
COMMENT ON COLUMN user_roles.scope_department_id IS '권한 범위 부서 ID (해당 부서에서만 권한 유효, NULL이면 전체)';
COMMENT ON COLUMN user_roles.scope_labor_office_id IS '권한 범위 노무사 사무실 ID (해당 사무실에서만 권한 유효)';
COMMENT ON COLUMN user_roles.start_date IS '역할 시작일 (권한 유효 시작일, 기본값 오늘)';
COMMENT ON COLUMN user_roles.end_date IS '역할 종료일 (NULL이면 무기한, 임시 권한 부여시 설정)';
COMMENT ON COLUMN user_roles.is_active IS '역할 활성화 여부 (TRUE:활성, FALSE:비활성)';
COMMENT ON COLUMN user_roles.assigned_by IS '역할 부여자 사용자 ID (누가 권한을 부여했는지 추적)';
COMMENT ON COLUMN user_roles.assigned_at IS '역할 부여일시 (권한 부여 시점 기록)';

-- ===============================
-- 2. 노무사 사무실 관리
-- ===============================

-- 2-1. 노무사 사무실 테이블
CREATE TABLE labor_offices (
    labor_office_id SERIAL PRIMARY KEY,
    office_name VARCHAR(200) NOT NULL,
    business_registration_number VARCHAR(20) UNIQUE,
    representative_name VARCHAR(100) NOT NULL,
    
    address TEXT NOT NULL,
    postal_code VARCHAR(10),
    phone_number VARCHAR(20),
    fax_number VARCHAR(20),
    email VARCHAR(100),
    website_url VARCHAR(200),
    
    license_type VARCHAR(30),
    license_number VARCHAR(50),
    license_date DATE,
    
    office_status VARCHAR(20) DEFAULT 'active' CHECK (office_status IN ('active', 'suspended', 'closed')),
    
    service_types TEXT[],
    specialization_areas TEXT[],
    jurisdiction_areas TEXT[],
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- labor_offices 테이블 코멘트
COMMENT ON TABLE labor_offices IS '노무사 사무실 기본 정보 관리 테이블';
COMMENT ON COLUMN labor_offices.labor_office_id IS '노무사 사무실 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN labor_offices.office_name IS '노무사 사무실명 (상호, 예: 김앤장 노무법인)';
COMMENT ON COLUMN labor_offices.business_registration_number IS '사업자등록번호 (노무사 사무실의, 10자리, 유니크)';
COMMENT ON COLUMN labor_offices.representative_name IS '대표자명 (대표 노무사 성명)';
COMMENT ON COLUMN labor_offices.address IS '사무실 주소 (소재지 전체 주소)';
COMMENT ON COLUMN labor_offices.postal_code IS '우편번호 (5자리 새 우편번호)';
COMMENT ON COLUMN labor_offices.phone_number IS '대표 전화번호 (02-123-4567 형식)';
COMMENT ON COLUMN labor_offices.fax_number IS '팩스번호 (02-123-4568 형식)';
COMMENT ON COLUMN labor_offices.email IS '대표 이메일 주소 (info@nomusaoffice.com)';
COMMENT ON COLUMN labor_offices.website_url IS '홈페이지 URL (http://www.nomusaoffice.com)';
COMMENT ON COLUMN labor_offices.license_type IS '자격 구분 (공인노무사, 사회보험노무사)';
COMMENT ON COLUMN labor_offices.license_number IS '노무사 자격증 번호 (대표자의 자격증 번호)';
COMMENT ON COLUMN labor_offices.license_date IS '자격 취득일 (대표자의 노무사 자격 취득일)';
COMMENT ON COLUMN labor_offices.office_status IS '사무실 상태 (active:정상영업, suspended:영업정지, closed:폐업)';
COMMENT ON COLUMN labor_offices.service_types IS '제공 서비스 유형 배열 (4대보험, 급여관리, 노무상담, 인사컨설팅 등)';
COMMENT ON COLUMN labor_offices.specialization_areas IS '전문 분야 배열 (건설업, 제조업, 서비스업, IT업 등)';
COMMENT ON COLUMN labor_offices.jurisdiction_areas IS '관할 지역 배열 (서울, 경기, 인천 등 서비스 가능 지역)';
COMMENT ON COLUMN labor_offices.created_at IS '사무실 등록일시 (시스템 가입일)';
COMMENT ON COLUMN labor_offices.updated_at IS '정보 최종 수정일시 (프로필 변경시 자동 업데이트)';

-- 2-2. 노무사 사무실 직원 테이블
CREATE TABLE labor_office_staff (
    staff_id SERIAL PRIMARY KEY,
    labor_office_id INTEGER NOT NULL REFERENCES labor_offices(labor_office_id),
    user_id INTEGER NOT NULL REFERENCES users(user_id),
    
    staff_number VARCHAR(20),
    position VARCHAR(50),
    department VARCHAR(50),
    
    license_type VARCHAR(30),
    license_number VARCHAR(50),
    license_date DATE,
    
    specialization TEXT[],
    max_clients INTEGER DEFAULT 20,
    
    hire_date DATE,
    employment_status VARCHAR(20) DEFAULT 'active' CHECK (employment_status IN ('active', 'inactive', 'resigned')),
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(labor_office_id, staff_number)
);

-- labor_office_staff 테이블 코멘트
COMMENT ON TABLE labor_office_staff IS '노무사 사무실 직원 관리 테이블';
COMMENT ON COLUMN labor_office_staff.staff_id IS '노무사 사무실 직원 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN labor_office_staff.labor_office_id IS '소속 노무사 사무실 ID (labor_offices 테이블 외래키)';
COMMENT ON COLUMN labor_office_staff.user_id IS '사용자 계정 ID (users 테이블 외래키, 로그인 계정 연결)';
COMMENT ON COLUMN labor_office_staff.staff_number IS '직원번호 (사무실 내 고유번호, S001, S002 등)';
COMMENT ON COLUMN labor_office_staff.position IS '직위 (대표 노무사, 선임 사무원, 매니저, 사무원 등)';
COMMENT ON COLUMN labor_office_staff.department IS '소속 부서 (인사팀, 4대보험팀, 급여팀, 상담팀 등)';
COMMENT ON COLUMN labor_office_staff.license_type IS '보유 자격 (공인노무사, 사회보험노무사, 사무원, 기타)';
COMMENT ON COLUMN labor_office_staff.license_number IS '자격증 번호 (해당 자격이 있는 경우 자격증 번호)';
COMMENT ON COLUMN labor_office_staff.license_date IS '자격 취득일 (해당 자격이 있는 경우 취득일)';
COMMENT ON COLUMN labor_office_staff.specialization IS '담당 전문분야 배열 (4대보험, 급여관리, 노동법, 인사컨설팅 등)';
COMMENT ON COLUMN labor_office_staff.max_clients IS '최대 담당 가능 고객사 수 (업무량 조절용, 기본 20개사)';
COMMENT ON COLUMN labor_office_staff.hire_date IS '입사일 (해당 노무사 사무실 입사일)';
COMMENT ON COLUMN labor_office_staff.employment_status IS '재직 상태 (active:재직, inactive:휴직, resigned:퇴사)';
COMMENT ON COLUMN labor_office_staff.created_at IS '직원 등록일시';
COMMENT ON COLUMN labor_office_staff.updated_at IS '직원 정보 최종 수정일시';

-- ===============================
-- 3. 클라이언트 회사 관리 테이블
-- ===============================
CREATE TABLE companies (
    company_id SERIAL PRIMARY KEY,
    company_name VARCHAR(200) NOT NULL,
    business_registration_number VARCHAR(20) NOT NULL UNIQUE,
    representative_name VARCHAR(100) NOT NULL,
    business_type VARCHAR(100),
    address TEXT NOT NULL,
    phone_number VARCHAR(20),
    email VARCHAR(100),
    
    workplace_insurance_number VARCHAR(20),
    np_insurance_number VARCHAR(20),
    hi_insurance_number VARCHAR(20),
    ei_insurance_number VARCHAR(20),
    wc_insurance_number VARCHAR(20),
    
    business_code VARCHAR(10),
    wc_business_type VARCHAR(10),
    ei_business_type VARCHAR(10),
    
    np_office VARCHAR(100),
    hi_office VARCHAR(100),
    ei_office VARCHAR(100),
    labor_office VARCHAR(100),
    
    labor_office_id INTEGER REFERENCES labor_offices(labor_office_id) NULL, -- Modified
    client_start_date DATE,
    client_end_date DATE,
    service_type VARCHAR(50)[] DEFAULT ARRAY['4insurance'],
    monthly_fee NUMERIC(12,2),
    responsible_staff_id INTEGER REFERENCES labor_office_staff(staff_id) NULL, -- Modified
    
    client_status VARCHAR(20) DEFAULT 'active' CHECK (client_status IN ('active', 'inactive', 'terminated')),
    special_notes TEXT,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- companies 테이블 코멘트
COMMENT ON TABLE companies IS '클라이언트 회사 정보 및 4대보험 사업장 번호 관리 테이블';
COMMENT ON COLUMN companies.company_id IS '회사 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN companies.company_name IS '회사명 (상호, 예: 주식회사 삼성전자)';
COMMENT ON COLUMN companies.business_registration_number IS '사업자등록번호 (10자리, 유니크, 하이픈 제외)';
COMMENT ON COLUMN companies.representative_name IS '대표자 성명 (법인등기부상 대표이사명)';
COMMENT ON COLUMN companies.business_type IS '업종 (제조업, 건설업, 서비스업, IT업 등)';
COMMENT ON COLUMN companies.address IS '회사 소재지 주소 (본사 주소)';
COMMENT ON COLUMN companies.phone_number IS '회사 대표 전화번호';
COMMENT ON COLUMN companies.email IS '회사 대표 이메일 주소';
COMMENT ON COLUMN companies.workplace_insurance_number IS '사업장관리번호 (고용노동부 부여, 4대보험 통합 사용)';
COMMENT ON COLUMN companies.np_insurance_number IS '국민연금 사업장번호 (국민연금공단 부여)';
COMMENT ON COLUMN companies.hi_insurance_number IS '건강보험 사업장번호 (건강보험공단 부여)';
COMMENT ON COLUMN companies.ei_insurance_number IS '고용보험 사업장번호 (고용센터 부여)';
COMMENT ON COLUMN companies.wc_insurance_number IS '산재보험 사업장번호 (근로복지공단 부여)';
COMMENT ON COLUMN companies.business_code IS '표준산업분류코드 (통계청 분류 기준, 4대보험 요율 적용용)';
COMMENT ON COLUMN companies.wc_business_type IS '산재보험 업종코드 (산재보험 요율 결정용)';
COMMENT ON COLUMN companies.ei_business_type IS '고용보험 업종구분 (일반, 건설업 등)';
COMMENT ON COLUMN companies.np_office IS '관할 국민연금공단 지사명';
COMMENT ON COLUMN companies.hi_office IS '관할 건강보험공단 지사명';
COMMENT ON COLUMN companies.ei_office IS '관할 고용센터명';
COMMENT ON COLUMN companies.labor_office IS '관할 지방고용노동청명';
COMMENT ON COLUMN companies.labor_office_id IS '담당 노무사 사무실 ID (계약된 노무사 사무실, 선택 사항)'; -- Modified comment
COMMENT ON COLUMN companies.client_start_date IS '노무사 서비스 계약 시작일';
COMMENT ON COLUMN companies.client_end_date IS '노무사 서비스 계약 종료일 (NULL이면 진행중)';
COMMENT ON COLUMN companies.service_type IS '제공하는 서비스 유형 배열 (4대보험, 급여관리, 노무상담 등)';
COMMENT ON COLUMN companies.monthly_fee IS '월 서비스 수수료 (원, 계약된 월정액)';
COMMENT ON COLUMN companies.responsible_staff_id IS '담당 노무사 또는 직원 ID (주담당자, 선택 사항)'; -- Modified comment
COMMENT ON COLUMN companies.client_status IS '고객사 상태 (active:활성, inactive:비활성, terminated:계약종료)';
COMMENT ON COLUMN companies.special_notes IS '고객사 특이사항 및 주의사항 메모';
COMMENT ON COLUMN companies.created_at IS '레코드 생성일시';
COMMENT ON COLUMN companies.updated_at IS '레코드 최종 수정일시';

-- ===============================
-- 4. 회사 부서/현장 관리
-- ===============================

-- 4-1. 부서/현장 테이블
CREATE TABLE departments (
    department_id SERIAL PRIMARY KEY,
    company_id INTEGER NOT NULL REFERENCES companies(company_id),
    
    department_code VARCHAR(20),
    department_name VARCHAR(100) NOT NULL,
    department_type VARCHAR(20) CHECK (department_type IN ('office', 'factory', 'construction_site', 'branch')),
    
    address TEXT,
    postal_code VARCHAR(10),
    
    phone_number VARCHAR(20),
    fax_number VARCHAR(20),
    
    manager_user_id INTEGER REFERENCES users(user_id),
    
    is_active BOOLEAN DEFAULT TRUE,
    
    parent_department_id INTEGER REFERENCES departments(department_id),
    depth_level INTEGER DEFAULT 1,
    sort_order INTEGER DEFAULT 0,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(company_id, department_code)
);

-- departments 테이블 코멘트
COMMENT ON TABLE departments IS '회사 부서/현장 관리 테이블 (계층 구조 지원)';
COMMENT ON COLUMN departments.department_id IS '부서/현장 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN departments.company_id IS '소속 회사 ID (companies 테이블 외래키)';
COMMENT ON COLUMN departments.department_code IS '부서 코드 (회사 내 고유, 예: DEV01, HR01, SITE001)';
COMMENT ON COLUMN departments.department_name IS '부서명/현장명 (개발팀, 인사팀, 1공장, 강남현장 등)';
COMMENT ON COLUMN departments.department_type IS '부서 유형 (office:사무실, factory:공장, construction_site:건설현장, branch:지점)';
COMMENT ON COLUMN departments.address IS '부서/현장 주소 (본사와 다른 경우 별도 주소)';
COMMENT ON COLUMN departments.postal_code IS '우편번호 (부서/현장 별도 우편번호)';
COMMENT ON COLUMN departments.phone_number IS '부서 전화번호 (내선번호 또는 직통번호)';
COMMENT ON COLUMN departments.fax_number IS '부서 팩스번호';
COMMENT ON COLUMN departments.manager_user_id IS '부서 관리자 사용자 ID (해당 부서 책임자, 회사 직원 중)';
COMMENT ON COLUMN departments.is_active IS '부서 활성화 여부 (TRUE:운영중, FALSE:폐쇄/비활성)';
COMMENT ON COLUMN departments.parent_department_id IS '상위 부서 ID (본사-지점-팀 계층구조 지원)';
COMMENT ON COLUMN departments.depth_level IS '부서 계층 깊이 (1:최상위, 2:2단계, 3:3단계...)';
COMMENT ON COLUMN departments.sort_order IS '정렬 순서 (같은 레벨 내에서의 표시 순서)';
COMMENT ON COLUMN departments.created_at IS '부서 생성일시';
COMMENT ON COLUMN departments.updated_at IS '부서 정보 최종 수정일시';

-- ===============================
-- 5. 사용자 담당 범위 관리
-- ===============================

-- 5-1. 사용자별 담당 회사 관리
CREATE TABLE user_company_assignments (
    assignment_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(user_id),
    company_id INTEGER NOT NULL REFERENCES companies(company_id),
    assignment_type VARCHAR(20) NOT NULL CHECK (assignment_type IN ('primary', 'secondary', 'backup')),
    
    responsibilities TEXT[],
    service_level VARCHAR(20) DEFAULT 'standard',
    
    start_date DATE NOT NULL DEFAULT CURRENT_DATE,
    end_date DATE,
    
    is_active BOOLEAN DEFAULT TRUE,
    assigned_by INTEGER REFERENCES users(user_id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- user_company_assignments 테이블 코멘트
COMMENT ON TABLE user_company_assignments IS '노무사 사무실 직원의 담당 회사 배정 관리';
COMMENT ON COLUMN user_company_assignments.assignment_id IS '담당 회사 배정 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN user_company_assignments.user_id IS '담당자 사용자 ID (노무사 사무실 직원)';
COMMENT ON COLUMN user_company_assignments.company_id IS '담당 회사 ID (클라이언트 회사)';
COMMENT ON COLUMN user_company_assignments.assignment_type IS '담당 유형 (primary:주담당, secondary:부담당, backup:백업담당)';
COMMENT ON COLUMN user_company_assignments.responsibilities IS '담당 업무 목록 배열 (4대보험관리, 급여계산, 근태관리, 노무상담, 현장방문 등)';
COMMENT ON COLUMN user_company_assignments.service_level IS '서비스 레벨 (standard:표준, premium:프리미엄, basic:기본)';
COMMENT ON COLUMN user_company_assignments.start_date IS '담당 시작일';
COMMENT ON COLUMN user_company_assignments.end_date IS '담당 종료일 (NULL이면 현재 담당중)';
COMMENT ON COLUMN user_company_assignments.is_active IS '현재 담당 여부 (TRUE:담당중, FALSE:담당종료)';
COMMENT ON COLUMN user_company_assignments.assigned_by IS '배정자 사용자 ID (누가 담당자를 배정했는지)';
COMMENT ON COLUMN user_company_assignments.created_at IS '담당 배정일시';

-- 5-2. 사용자별 담당 부서 관리
CREATE TABLE user_department_assignments (
    assignment_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(user_id),
    department_id INTEGER NOT NULL REFERENCES departments(department_id),
    assignment_type VARCHAR(20) NOT NULL CHECK (assignment_type IN ('manager', 'supervisor', 'staff')),
    
    can_manage_workers BOOLEAN DEFAULT FALSE,
    can_manage_attendance BOOLEAN DEFAULT FALSE,
    can_view_payroll BOOLEAN DEFAULT FALSE,
    can_manage_insurance BOOLEAN DEFAULT FALSE,
    
    start_date DATE NOT NULL DEFAULT CURRENT_DATE,
    end_date DATE,
    
    is_active BOOLEAN DEFAULT TRUE,
    assigned_by INTEGER REFERENCES users(user_id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- user_department_assignments 테이블 코멘트
COMMENT ON TABLE user_department_assignments IS '회사 직원의 담당 부서 배정 관리 (회사 내부 권한)';
COMMENT ON COLUMN user_department_assignments.assignment_id IS '담당 부서 배정 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN user_department_assignments.user_id IS '담당자 사용자 ID (회사 직원)';
COMMENT ON COLUMN user_department_assignments.department_id IS '담당 부서/현장 ID';
COMMENT ON COLUMN user_department_assignments.assignment_type IS '담당 유형 (manager:관리자, supervisor:감독자, staff:일반직원)';
COMMENT ON COLUMN user_department_assignments.can_manage_workers IS '근로자 관리 권한 (TRUE:가능, FALSE:불가능)';
COMMENT ON COLUMN user_department_assignments.can_manage_attendance IS '근태 관리 권한 (TRUE:가능, FALSE:불가능)';
COMMENT ON COLUMN user_department_assignments.can_view_payroll IS '급여 조회 권한 (TRUE:가능, FALSE:불가능)';
COMMENT ON COLUMN user_department_assignments.can_manage_insurance IS '4대보험 관리 권한 (TRUE:가능, FALSE:불가능)';
COMMENT ON COLUMN user_department_assignments.start_date IS '담당 시작일';
COMMENT ON COLUMN user_department_assignments.end_date IS '담당 종료일 (NULL이면 현재 담당중)';
COMMENT ON COLUMN user_department_assignments.is_active IS '담당 활성화 여부 (TRUE:담당중, FALSE:담당종료)';
COMMENT ON COLUMN user_department_assignments.assigned_by IS '배정자 사용자 ID (누가 담당자를 배정했는지)';
COMMENT ON COLUMN user_department_assignments.created_at IS '담당 배정일시';

-- ===============================
-- 6. 4대보험 요율 관리 테이블
-- ===============================
CREATE TABLE insurance_rates (
    rate_id SERIAL PRIMARY KEY,
    apply_year INTEGER NOT NULL,
    apply_month INTEGER NOT NULL,
    
    np_employee_rate DECIMAL(5,4) NOT NULL DEFAULT 0.045,
    np_employer_rate DECIMAL(5,4) NOT NULL DEFAULT 0.045,
    np_max_income NUMERIC(12,2) DEFAULT 5690000,
    np_min_income NUMERIC(12,2) DEFAULT 370000,
    
    hi_employee_rate DECIMAL(5,4) NOT NULL DEFAULT 0.0354,
    hi_employer_rate DECIMAL(5,4) NOT NULL DEFAULT 0.0354,
    hi_max_income NUMERIC(12,2) DEFAULT 11520000,
    hi_min_income NUMERIC(12,2) DEFAULT 370000,
    
    ltc_rate DECIMAL(5,4) NOT NULL DEFAULT 0.004681,
    
    ei_employee_rate DECIMAL(5,4) NOT NULL DEFAULT 0.009,
    ei_employer_rate DECIMAL(5,4) NOT NULL DEFAULT 0.0135,
    ei_max_income NUMERIC(12,2) DEFAULT 13670000,
    
    wc_rates JSONB,
    
    effective_date DATE NOT NULL,
    expiry_date DATE,
    is_active BOOLEAN DEFAULT TRUE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(apply_year, apply_month)
);

-- insurance_rates 테이블 코멘트
COMMENT ON TABLE insurance_rates IS '연도별 4대보험 요율 정보 관리 테이블';
COMMENT ON COLUMN insurance_rates.rate_id IS '보험요율 정보 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN insurance_rates.apply_year IS '적용 연도 (2024, 2025 등)';
COMMENT ON COLUMN insurance_rates.apply_month IS '적용 월 (1-12, 연중 요율 변경시 사용)';
COMMENT ON COLUMN insurance_rates.np_employee_rate IS '국민연금 근로자 부담률 (소수점 4자리, 예: 0.045 = 4.5%)';
COMMENT ON COLUMN insurance_rates.np_employer_rate IS '국민연금 사용자 부담률 (소수점 4자리, 예: 0.045 = 4.5%)';
COMMENT ON COLUMN insurance_rates.np_max_income IS '국민연금 기준소득월액 상한 (원, 2024년 기준 569만원)';
COMMENT ON COLUMN insurance_rates.np_min_income IS '국민연금 기준소득월액 하한 (원, 2024년 기준 37만원)';
COMMENT ON COLUMN insurance_rates.hi_employee_rate IS '건강보험 근로자 부담률 (소수점 4자리, 예: 0.0354 = 3.54%)';
COMMENT ON COLUMN insurance_rates.hi_employer_rate IS '건강보험 사용자 부담률 (소수점 4자리, 예: 0.0354 = 3.54%)';
COMMENT ON COLUMN insurance_rates.hi_max_income IS '건강보험 보수월액 상한 (원, 2024년 기준 1152만원)';
COMMENT ON COLUMN insurance_rates.hi_min_income IS '건강보험 보수월액 하한 (원, 2024년 기준 37만원)';
COMMENT ON COLUMN insurance_rates.ltc_rate IS '장기요양보험료율 (건강보험료의 일정 비율, 소수점 6자리)';
COMMENT ON COLUMN insurance_rates.ei_employee_rate IS '고용보험 근로자 부담률 (소수점 4자리, 예: 0.009 = 0.9%)';
COMMENT ON COLUMN insurance_rates.ei_employer_rate IS '고용보험 사용자 부담률 (소수점 4자리, 예: 0.0135 = 1.35%)';
COMMENT ON COLUMN insurance_rates.ei_max_income IS '고용보험 보수월액 상한 (원, 2024년 기준 1367만원)';
COMMENT ON COLUMN insurance_rates.wc_rates IS '업종코드별 산재보험 요율 정보 JSON ({"건설업": 0.018, "제조업": 0.015})';
COMMENT ON COLUMN insurance_rates.effective_date IS '요율 시행일 (실제 적용 시작일)';
COMMENT ON COLUMN insurance_rates.expiry_date IS '요율 만료일 (NULL이면 현재 적용중)';
COMMENT ON COLUMN insurance_rates.is_active IS '현재 사용중인 요율 여부 (TRUE:현재적용, FALSE:과거요율)';
COMMENT ON COLUMN insurance_rates.created_at IS '레코드 생성일시';

-- ===============================
-- 7. 4대보험 가입조건 마스터 테이블
-- ===============================
CREATE TABLE insurance_eligibility_criteria (
    criteria_id SERIAL PRIMARY KEY,
    employment_type_code VARCHAR(20) NOT NULL,
    insurance_type VARCHAR(20) NOT NULL CHECK (insurance_type IN ('NP', 'HI', 'EI', 'WC')),
    
    criteria_type VARCHAR(20) NOT NULL CHECK (criteria_type IN ('mandatory', 'optional', 'voluntary')),
    
    min_work_days INTEGER DEFAULT 0,
    min_work_hours DECIMAL(5,2) DEFAULT 0,
    min_monthly_income NUMERIC(12,2) DEFAULT 0,
    min_employment_period_months INTEGER DEFAULT 0,
    
    additional_conditions JSONB,
    
    legal_basis TEXT,
    description TEXT,
    
    effective_date DATE NOT NULL,
    expiry_date DATE,
    is_active BOOLEAN DEFAULT TRUE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- insurance_eligibility_criteria 테이블 코멘트
COMMENT ON TABLE insurance_eligibility_criteria IS '4대보험 가입조건 마스터 테이블 (의무/선택가입 기준)';
COMMENT ON COLUMN insurance_eligibility_criteria.criteria_id IS '가입조건 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN insurance_eligibility_criteria.employment_type_code IS '고용형태 코드 (REGULAR, CONTRACT, PART_TIME, DAILY)';
COMMENT ON COLUMN insurance_eligibility_criteria.insurance_type IS '보험 구분 (NP:국민연금, HI:건강보험, EI:고용보험, WC:산재보험)';
COMMENT ON COLUMN insurance_eligibility_criteria.criteria_type IS '가입 조건 타입 (mandatory:의무가입, optional:조건부가입, voluntary:선택가입)';
COMMENT ON COLUMN insurance_eligibility_criteria.min_work_days IS '최소 근무일수 (월 기준, 예: 일용직 8일)';
COMMENT ON COLUMN insurance_eligibility_criteria.min_work_hours IS '최소 근무시간 (월 기준, 예: 단시간 60시간)';
COMMENT ON COLUMN insurance_eligibility_criteria.min_monthly_income IS '최소 월소득 (원, 예: 국민연금 220만원)';
COMMENT ON COLUMN insurance_eligibility_criteria.min_employment_period_months IS '최소 고용기간 (개월, 예: 3개월 이상)';
COMMENT ON COLUMN insurance_eligibility_criteria.additional_conditions IS '추가 조건 JSON ({"requires_employer_consent": true, "requires_worker_consent": true})';
COMMENT ON COLUMN insurance_eligibility_criteria.legal_basis IS '법적 근거 (소관 법령명, 예: 국민연금법 제6조)';
COMMENT ON COLUMN insurance_eligibility_criteria.description IS '가입조건 상세 설명';
COMMENT ON COLUMN insurance_eligibility_criteria.effective_date IS '조건 시행일 (법령 시행일)';
COMMENT ON COLUMN insurance_eligibility_criteria.expiry_date IS '조건 만료일 (NULL이면 현재 적용중)';
COMMENT ON COLUMN insurance_eligibility_criteria.is_active IS '현재 적용중인 조건 여부';
COMMENT ON COLUMN insurance_eligibility_criteria.created_at IS '레코드 생성일시';

-- ===============================
-- 8. 고용형태별 4대보험 적용기준 테이블
-- ===============================
CREATE TABLE employment_types (
    employment_type_id SERIAL PRIMARY KEY,
    type_code VARCHAR(20) NOT NULL UNIQUE,
    type_name VARCHAR(100) NOT NULL,
    type_category VARCHAR(20) NOT NULL CHECK (type_category IN ('regular', 'contract', 'part_time', 'daily')),
    
    judgment_method VARCHAR(20) NOT NULL CHECK (judgment_method IN ('immediate', 'monthly', 'rolling_monthly')),
    
    np_criteria JSONB,
    hi_criteria JSONB,
    ei_criteria JSONB,
    wc_criteria JSONB,
    
    np_voluntary_allowed BOOLEAN DEFAULT FALSE,
    hi_voluntary_allowed BOOLEAN DEFAULT FALSE,
    ei_voluntary_allowed BOOLEAN DEFAULT FALSE,
    wc_voluntary_allowed BOOLEAN DEFAULT FALSE,
    
    np_special_rules TEXT,
    hi_special_rules TEXT,
    ei_special_rules TEXT,
    wc_special_rules TEXT,
    
    legal_definition TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- employment_types 테이블 코멘트
COMMENT ON TABLE employment_types IS '고용형태별 4대보험 적용기준 테이블 (판정 방식 정의)';
COMMENT ON COLUMN employment_types.employment_type_id IS '고용형태 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN employment_types.type_code IS '고용형태 코드 (REGULAR:정규직, CONTRACT:계약직, PART_TIME:단시간, DAILY:일용직)';
COMMENT ON COLUMN employment_types.type_name IS '고용형태명 (정규직, 계약직, 단시간근로자, 일용직 등)';
COMMENT ON COLUMN employment_types.type_category IS '고용형태 대분류 (regular:정규직, contract:계약직, part_time:단시간, daily:일용직)';
COMMENT ON COLUMN employment_types.judgment_method IS '4대보험 가입 판정방식 (immediate:즉시가입, monthly:달력월별, rolling_monthly:입사일기준순환)';
COMMENT ON COLUMN employment_types.np_criteria IS '국민연금 가입기준 JSON (min_days, min_hours, monthly_income, immediate 등)';
COMMENT ON COLUMN employment_types.hi_criteria IS '건강보험 가입기준 JSON (min_days, min_hours, monthly_income, immediate 등)';
COMMENT ON COLUMN employment_types.ei_criteria IS '고용보험 가입기준 JSON (min_days, min_hours, monthly_income, immediate 등)';
COMMENT ON COLUMN employment_types.wc_criteria IS '산재보험 가입기준 JSON (min_days, min_hours, monthly_income, immediate 등)';
COMMENT ON COLUMN employment_types.np_voluntary_allowed IS '국민연금 선택가입 허용 여부 (TRUE:허용, FALSE:불허)';
COMMENT ON COLUMN employment_types.hi_voluntary_allowed IS '건강보험 선택가입 허용 여부 (TRUE:허용, FALSE:불허)';
COMMENT ON COLUMN employment_types.ei_voluntary_allowed IS '고용보험 선택가입 허용 여부 (TRUE:허용, FALSE:불허)';
COMMENT ON COLUMN employment_types.wc_voluntary_allowed IS '산재보험 선택가입 허용 여부 (TRUE:허용, FALSE:불허)';
COMMENT ON COLUMN employment_types.np_special_rules IS '국민연금 특별 적용 규정 및 예외사항';
COMMENT ON COLUMN employment_types.hi_special_rules IS '건강보험 특별 적용 규정 및 예외사항';
COMMENT ON COLUMN employment_types.ei_special_rules IS '고용보험 특별 적용 규정 및 예외사항';
COMMENT ON COLUMN employment_types.wc_special_rules IS '산재보험 특별 적용 규정 및 예외사항';
COMMENT ON COLUMN employment_types.legal_definition IS '고용형태의 법적 정의 (근로기준법, 사회보험법 등 법령 기준)';
COMMENT ON COLUMN employment_types.is_active IS '현재 사용중인 고용형태 여부 (TRUE:사용, FALSE:사용안함)';
COMMENT ON COLUMN employment_types.created_at IS '레코드 생성일시';

-- ===============================
-- 9. 근로자 기본정보 테이블
-- ===============================
CREATE TABLE workers (
    worker_id SERIAL PRIMARY KEY,
    company_id INTEGER NOT NULL REFERENCES companies(company_id),
    department_id INTEGER REFERENCES departments(department_id),
    employee_number VARCHAR(20),
    
    name VARCHAR(50) NOT NULL,
    eng_name VARCHAR(50),
    resident_number VARCHAR(20) NOT NULL,
    birth_date DATE,
    gender CHAR(1) CHECK (gender IN ('M', 'F')),
    nationality_code VARCHAR(10) NOT NULL,
    
    foreigner_registration_number VARCHAR(20),
    passport_number VARCHAR(20),
    visa_type VARCHAR(10),
    visa_expiry_date DATE,
    work_permit_number VARCHAR(50),
    
    address TEXT NOT NULL,
    postal_code VARCHAR(10),
    phone_number VARCHAR(20) NOT NULL,
    mobile_number VARCHAR(20),
    email VARCHAR(100),
    emergency_contact_name VARCHAR(50),
    emergency_contact_phone VARCHAR(20),
    
    bank_name VARCHAR(100),
    bank_account VARCHAR(100),
    account_holder_name VARCHAR(50),
    
    employment_type_id INTEGER REFERENCES employment_types(employment_type_id),
    hire_date DATE NOT NULL,
    resignation_date DATE,
    position VARCHAR(100),
    
    np_number VARCHAR(20),
    hi_number VARCHAR(20),
    existing_np_subscriber BOOLEAN DEFAULT FALSE,
    existing_hi_subscriber BOOLEAN DEFAULT FALSE,
    
    employment_status VARCHAR(20) DEFAULT 'active' CHECK (employment_status IN ('active', 'resigned', 'suspended')),
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(company_id, employee_number)
);

-- workers 테이블 코멘트
COMMENT ON TABLE workers IS '근로자 기본정보 테이블 (4대보험 특화)';
COMMENT ON COLUMN workers.worker_id IS '근로자 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN workers.company_id IS '소속 회사 ID (companies 테이블 외래키)';
COMMENT ON COLUMN workers.department_id IS '소속 부서/현장 ID (departments 테이블 외래키)';
COMMENT ON COLUMN workers.employee_number IS '사원번호 (회사별 고유, 급여대장 등에 사용)';
COMMENT ON COLUMN workers.name IS '근로자 성명 (한글, 급여명세서 등에 표시)';
COMMENT ON COLUMN workers.eng_name IS '근로자 영문명 (외국인의 경우 필수)';
COMMENT ON COLUMN workers.resident_number IS '주민등록번호 또는 외국인등록번호 (암호화 저장 필요)';
COMMENT ON COLUMN workers.birth_date IS '생년월일 (주민등록번호에서 추출 또는 별도 입력)';
COMMENT ON COLUMN workers.gender IS '성별 (M:남성, F:여성)';
COMMENT ON COLUMN workers.nationality_code IS '국적 코드 (KR:대한민국, CN:중국, VN:베트남 등)';
COMMENT ON COLUMN workers.foreigner_registration_number IS '외국인등록번호 (외국인의 경우)';
COMMENT ON COLUMN workers.passport_number IS '여권번호 (외국인의 경우)';
COMMENT ON COLUMN workers.visa_type IS '체류자격 (E-9, H-2, F-4 등)';
COMMENT ON COLUMN workers.visa_expiry_date IS '체류기간 만료일 (비자 갱신 관리용)';
COMMENT ON COLUMN workers.work_permit_number IS '취업허가번호 (외국인의 경우)';
COMMENT ON COLUMN workers.address IS '주소 (주민등록상 주소)';
COMMENT ON COLUMN workers.postal_code IS '우편번호';
COMMENT ON COLUMN workers.phone_number IS '자택 전화번호';
COMMENT ON COLUMN workers.mobile_number IS '휴대전화번호 (주 연락처)';
COMMENT ON COLUMN workers.email IS '이메일 주소';
COMMENT ON COLUMN workers.emergency_contact_name IS '비상연락처 성명 (가족 등)';
COMMENT ON COLUMN workers.emergency_contact_phone IS '비상연락처 전화번호';
COMMENT ON COLUMN workers.bank_name IS '급여계좌 은행명';
COMMENT ON COLUMN workers.bank_account IS '급여계좌 번호 (암호화 저장 필요)';
COMMENT ON COLUMN workers.account_holder_name IS '급여계좌 예금주명';
COMMENT ON COLUMN workers.employment_type_id IS '고용형태 ID (employment_types 테이블 외래키)';
COMMENT ON COLUMN workers.hire_date IS '입사일 (4대보험 취득일 기준)';
COMMENT ON COLUMN workers.resignation_date IS '퇴사일 (4대보험 상실일 기준)';
COMMENT ON COLUMN workers.position IS '직책 또는 직급 (과장, 대리, 기사 등)';
COMMENT ON COLUMN workers.np_number IS '국민연금번호 (국민연금공단 부여)';
COMMENT ON COLUMN workers.hi_number IS '건강보험증번호';
COMMENT ON COLUMN workers.existing_np_subscriber IS '기존 국민연금 가입자 여부 (다른 직장에서 이미 가입)';
COMMENT ON COLUMN workers.existing_hi_subscriber IS '기존 건강보험 가입자 여부 (다른 직장에서 이미 가입)';
COMMENT ON COLUMN workers.employment_status IS '재직 상태 (active:재직, resigned:퇴직, suspended:휴직)';
COMMENT ON COLUMN workers.created_at IS '레코드 생성일시';
COMMENT ON COLUMN workers.updated_at IS '레코드 최종 수정일시';

-- ===============================
-- 10. 근로자별 4대보험 선택가입 관리 테이블
-- ===============================
CREATE TABLE worker_voluntary_insurance (
    voluntary_id SERIAL PRIMARY KEY,
    worker_id INTEGER NOT NULL REFERENCES workers(worker_id),
    insurance_type VARCHAR(20) NOT NULL CHECK (insurance_type IN ('NP', 'HI', 'EI', 'WC')),
    
    application_date DATE NOT NULL,
    worker_consent BOOLEAN DEFAULT FALSE,
    employer_consent BOOLEAN DEFAULT FALSE,
    
    application_reason TEXT,
    
    approval_status VARCHAR(20) DEFAULT 'pending' CHECK (approval_status IN ('pending', 'approved', 'rejected')),
    approved_by INTEGER REFERENCES users(user_id),
    approved_date DATE,
    rejection_reason TEXT,
    
    voluntary_start_date DATE,
    voluntary_end_date DATE,
    
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(worker_id, insurance_type, application_date)
);

-- worker_voluntary_insurance 테이블 코멘트
COMMENT ON TABLE worker_voluntary_insurance IS '근로자별 4대보험 선택가입 신청 및 승인 관리';
COMMENT ON COLUMN worker_voluntary_insurance.voluntary_id IS '선택가입 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN worker_voluntary_insurance.worker_id IS '근로자 ID (workers 테이블 외래키)';
COMMENT ON COLUMN worker_voluntary_insurance.insurance_type IS '보험 구분 (NP:국민연금, HI:건강보험, EI:고용보험, WC:산재보험)';
COMMENT ON COLUMN worker_voluntary_insurance.application_date IS '선택가입 신청일';
COMMENT ON COLUMN worker_voluntary_insurance.worker_consent IS '근로자 동의 여부 (TRUE:동의, FALSE:미동의)';
COMMENT ON COLUMN worker_voluntary_insurance.employer_consent IS '사용자(회사) 동의 여부 (TRUE:동의, FALSE:미동의)';
COMMENT ON COLUMN worker_voluntary_insurance.application_reason IS '선택가입 신청 사유 (근로자가 기재)';
COMMENT ON COLUMN worker_voluntary_insurance.approval_status IS '승인 상태 (pending:승인대기, approved:승인, rejected:반려)';
COMMENT ON COLUMN worker_voluntary_insurance.approved_by IS '승인자 사용자 ID (누가 승인했는지)';
COMMENT ON COLUMN worker_voluntary_insurance.approved_date IS '승인일';
COMMENT ON COLUMN worker_voluntary_insurance.rejection_reason IS '반려 사유 (승인이 거부된 경우)';
COMMENT ON COLUMN worker_voluntary_insurance.voluntary_start_date IS '선택가입 시작일 (실제 보험 적용 시작일)';
COMMENT ON COLUMN worker_voluntary_insurance.voluntary_end_date IS '선택가입 종료일 (NULL이면 계속 가입)';
COMMENT ON COLUMN worker_voluntary_insurance.is_active IS '현재 유효한 선택가입 여부 (TRUE:유효, FALSE:무효)';
COMMENT ON COLUMN worker_voluntary_insurance.created_at IS '선택가입 신청일시';

-- ===============================
-- 11. 비과세 한도 관리 테이블
-- ===============================
CREATE TABLE nontax_limits (
    limit_id SERIAL PRIMARY KEY,
    company_id INTEGER REFERENCES companies(company_id),
    limit_type VARCHAR(30) NOT NULL,
    limit_name VARCHAR(100) NOT NULL,
    monthly_limit NUMERIC(12,2),
    annual_limit NUMERIC(12,2),
    
    effective_date DATE NOT NULL,
    expiry_date DATE,
    is_legal_limit BOOLEAN DEFAULT TRUE,
    legal_reference TEXT,
    description TEXT,
    special_conditions TEXT,
    
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- nontax_limits 테이블 코멘트
COMMENT ON TABLE nontax_limits IS '비과세 한도 관리 테이블 (회사별/항목별 설정 가능)';
COMMENT ON COLUMN nontax_limits.limit_id IS '비과세 한도 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN nontax_limits.company_id IS '적용 회사 ID (NULL이면 전체 회사 공통 적용)';
COMMENT ON COLUMN nontax_limits.limit_type IS '비과세 항목 유형 코드 (meal_allowance, transport_allowance, car_maintenance 등)';
COMMENT ON COLUMN nontax_limits.limit_name IS '비과세 항목명 (식대, 교통비, 자가운전보조금 등)';
COMMENT ON COLUMN nontax_limits.monthly_limit IS '월 한도액 (원, NULL이면 월 한도 없음)';
COMMENT ON COLUMN nontax_limits.annual_limit IS '연 한도액 (원, NULL이면 연 한도 없음)';
COMMENT ON COLUMN nontax_limits.effective_date IS '한도 적용 시작일';
COMMENT ON COLUMN nontax_limits.expiry_date IS '한도 적용 종료일 (NULL이면 계속 적용)';
COMMENT ON COLUMN nontax_limits.is_legal_limit IS '법정 한도 여부 (TRUE:법령에서 정한 한도, FALSE:회사 자체 설정 한도)';
COMMENT ON COLUMN nontax_limits.legal_reference IS '법적 근거 (소득세법 시행령 제12조 등 관련 법령)';
COMMENT ON COLUMN nontax_limits.description IS '한도 상세 설명 (적용 조건, 특이사항 등)';
COMMENT ON COLUMN nontax_limits.special_conditions IS '특별 조건 (근무지역별 차등, 직급별 차등, 기타 특별 적용 조건)';
COMMENT ON COLUMN nontax_limits.is_active IS '현재 적용중인 한도 여부 (TRUE:적용중, FALSE:적용안함)';
COMMENT ON COLUMN nontax_limits.created_at IS '한도 설정일시';

-- ===============================
-- 12. 급여 항목 마스터 테이블
-- ===============================
CREATE TABLE payroll_item_types (
    item_type_id SERIAL PRIMARY KEY,
    item_code VARCHAR(30) NOT NULL UNIQUE,
    default_name VARCHAR(100) NOT NULL,
    
    item_category VARCHAR(20) NOT NULL CHECK (item_category IN ('basic_pay', 'allowance', 'overtime', 'deduction')),
    
    tax_type VARCHAR(20) NOT NULL DEFAULT 'taxable' CHECK (tax_type IN ('taxable', 'nontax', 'mixed')),
    
    insurance_included BOOLEAN DEFAULT TRUE,
    
    calculation_method VARCHAR(20) CHECK (calculation_method IN ('fixed', 'hourly', 'daily', 'percentage')),
    
    nontax_limit_type VARCHAR(30),
    
    description TEXT,
    calculation_formula TEXT,
    
    is_system_default BOOLEAN DEFAULT TRUE,
    is_active BOOLEAN DEFAULT TRUE,
    sort_order INTEGER DEFAULT 0,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- payroll_item_types 테이블 코멘트
COMMENT ON TABLE payroll_item_types IS '급여 항목 마스터 테이블 (시스템 전체 급여 항목 정의)';
COMMENT ON COLUMN payroll_item_types.item_type_id IS '급여 항목 타입 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN payroll_item_types.item_code IS '급여 항목 코드 (BASE_SALARY, OVERTIME, MEAL, TRANSPORT 등, 시스템에서 참조)';
COMMENT ON COLUMN payroll_item_types.default_name IS '기본 항목명 (기본급, 연장근로수당, 식대, 교통비 등)';
COMMENT ON COLUMN payroll_item_types.item_category IS '항목 분류 (basic_pay:기본급, allowance:수당, overtime:초과근무, deduction:공제)';
COMMENT ON COLUMN payroll_item_types.tax_type IS '과세 구분 (taxable:과세, nontax:비과세, mixed:혼합)';
COMMENT ON COLUMN payroll_item_types.insurance_included IS '4대보험 포함 여부 (TRUE:포함, FALSE:제외)';
COMMENT ON COLUMN payroll_item_types.calculation_method IS '계산 방식 (fixed:고정금액, hourly:시간당, daily:일당, percentage:비율)';
COMMENT ON COLUMN payroll_item_types.nontax_limit_type IS '비과세 한도 연결 (nontax_limits.limit_type과 연결)';
COMMENT ON COLUMN payroll_item_types.description IS '항목 설명 (사용 용도 및 특징 설명)';
COMMENT ON COLUMN payroll_item_types.calculation_formula IS '계산 공식 (시간당, 일당 계산 방법 등)';
COMMENT ON COLUMN payroll_item_types.is_system_default IS '시스템 기본 항목 여부 (TRUE:시스템기본, FALSE:사용자추가)';
COMMENT ON COLUMN payroll_item_types.is_active IS '사용 가능 여부 (TRUE:사용, FALSE:사용안함)';
COMMENT ON COLUMN payroll_item_types.sort_order IS '정렬 순서 (급여명세서 표시 순서)';
COMMENT ON COLUMN payroll_item_types.created_at IS '항목 생성일시';

-- ===============================
-- 13. 회사별 급여 항목 설정 테이블
-- ===============================
CREATE TABLE company_payroll_items (
    company_payroll_item_id SERIAL PRIMARY KEY,
    company_id INTEGER NOT NULL REFERENCES companies(company_id),
    item_type_id INTEGER NOT NULL REFERENCES payroll_item_types(item_type_id),
    
    custom_name VARCHAR(100),
    custom_description TEXT,
    
    is_taxable BOOLEAN,
    is_insurance_included BOOLEAN,
    
    custom_nontax_limit NUMERIC(12,2),
    
    is_active BOOLEAN DEFAULT TRUE,
    is_mandatory BOOLEAN DEFAULT FALSE,
    sort_order INTEGER DEFAULT 0,
    
    editable_by_company BOOLEAN DEFAULT TRUE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(company_id, item_type_id)
);

-- company_payroll_items 테이블 코멘트
COMMENT ON TABLE company_payroll_items IS '회사별 급여 항목 설정 테이블 (커스터마이징 지원)';
COMMENT ON COLUMN company_payroll_items.company_payroll_item_id IS '회사 급여항목 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN company_payroll_items.company_id IS '회사 ID (companies 테이블 외래키)';
COMMENT ON COLUMN company_payroll_items.item_type_id IS '급여 항목 타입 ID (payroll_item_types 테이블 외래키)';
COMMENT ON COLUMN company_payroll_items.custom_name IS '회사별 커스텀 항목명 (NULL이면 기본명 사용, 예: "위험수당" → "고소작업수당")';
COMMENT ON COLUMN company_payroll_items.custom_description IS '회사별 항목 설명 (회사 특화 설명)';
COMMENT ON COLUMN company_payroll_items.is_taxable IS '과세 여부 오버라이드 (NULL이면 기본 설정 사용)';
COMMENT ON COLUMN company_payroll_items.is_insurance_included IS '4대보험 포함 여부 오버라이드 (NULL이면 기본 설정 사용)';
COMMENT ON COLUMN company_payroll_items.custom_nontax_limit IS '회사별 특별 비과세 한도 (NULL이면 기본 한도 사용)';
COMMENT ON COLUMN company_payroll_items.is_active IS '사용 여부 (TRUE:사용, FALSE:사용안함)';
COMMENT ON COLUMN company_payroll_items.is_mandatory IS '필수 항목 여부 (TRUE:필수, FALSE:선택)';
COMMENT ON COLUMN company_payroll_items.sort_order IS '회사별 정렬 순서 (급여명세서 표시 순서)';
COMMENT ON COLUMN company_payroll_items.editable_by_company IS '회사에서 편집 가능 여부 (TRUE:편집가능, FALSE:읽기전용)';
COMMENT ON COLUMN company_payroll_items.created_at IS '설정 생성일시';
COMMENT ON COLUMN company_payroll_items.updated_at IS '설정 최종 수정일시';

-- ===============================
-- 14. 근로자별 급여 상세 테이블
-- ===============================
CREATE TABLE worker_payroll_details (
    payroll_detail_id SERIAL PRIMARY KEY,
    worker_id INTEGER NOT NULL REFERENCES workers(worker_id),
    company_payroll_item_id INTEGER NOT NULL REFERENCES company_payroll_items(company_payroll_item_id),
    
    pay_year INTEGER NOT NULL,
    pay_month INTEGER NOT NULL,
    
    gross_amount NUMERIC(12,2) NOT NULL DEFAULT 0,
    nontax_amount NUMERIC(12,2) DEFAULT 0,
    tax_excess_amount NUMERIC(12,2) DEFAULT 0,
    taxable_amount NUMERIC(12,2) GENERATED ALWAYS AS (gross_amount - nontax_amount) STORED,
    
    calculation_base NUMERIC(12,2),
    unit_price NUMERIC(12,2),
    
    notes TEXT,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(worker_id, company_payroll_item_id, pay_year, pay_month)
);

-- worker_payroll_details 테이블 코멘트
COMMENT ON TABLE worker_payroll_details IS '근로자별 급여 상세 테이블 (동적 급여 항목 관리)';
COMMENT ON COLUMN worker_payroll_details.payroll_detail_id IS '급여 상세 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN worker_payroll_details.worker_id IS '근로자 ID (workers 테이블 외래키)';
COMMENT ON COLUMN worker_payroll_details.company_payroll_item_id IS '회사 급여항목 ID (company_payroll_items 테이블 외래키)';
COMMENT ON COLUMN worker_payroll_details.pay_year IS '급여 연도 (2024, 2025 등)';
COMMENT ON COLUMN worker_payroll_details.pay_month IS '급여 월 (1-12)';
COMMENT ON COLUMN worker_payroll_details.gross_amount IS '총 지급액 (세전 총 금액)';
COMMENT ON COLUMN worker_payroll_details.nontax_amount IS '비과세 금액 (한도 내 비과세 처리된 금액)';
COMMENT ON COLUMN worker_payroll_details.tax_excess_amount IS '비과세 한도 초과분 (과세로 전환된 금액)';
COMMENT ON COLUMN worker_payroll_details.taxable_amount IS '과세 금액 (총지급액 - 비과세금액, 자동계산)';
COMMENT ON COLUMN worker_payroll_details.calculation_base IS '계산 근거 (시간, 일수, 기준금액 등)';
COMMENT ON COLUMN worker_payroll_details.unit_price IS '단가 (시간당, 일당, 기준단가 등)';
COMMENT ON COLUMN worker_payroll_details.notes IS '메모 (특이사항, 조정사유 등)';
COMMENT ON COLUMN worker_payroll_details.created_at IS '급여 상세 입력일시';

-- ===============================
-- 15. 월별 급여 집계 테이블
-- ===============================
CREATE TABLE monthly_payroll (
    payroll_id SERIAL PRIMARY KEY,
    worker_id INTEGER NOT NULL REFERENCES workers(worker_id),
    pay_year INTEGER NOT NULL,
    pay_month INTEGER NOT NULL,

    work_days INTEGER NOT NULL DEFAULT 0,
    total_work_hours DECIMAL(6,2) DEFAULT 0,

    total_gross_pay NUMERIC(12,2) DEFAULT 0,
    total_taxable_pay NUMERIC(12,2) DEFAULT 0,
    total_nontax_pay NUMERIC(12,2) DEFAULT 0,
    total_tax_excess NUMERIC(12,2) DEFAULT 0,

    np_standard_income NUMERIC(12,2),
    hi_standard_income NUMERIC(12,2),
    ei_standard_income NUMERIC(12,2),

    np_premium NUMERIC(12,2) DEFAULT 0,
    hi_premium NUMERIC(12,2) DEFAULT 0,
    ltc_premium NUMERIC(12,2) DEFAULT 0,
    ei_premium NUMERIC(12,2) DEFAULT 0,

    income_tax_base NUMERIC(12,2) GENERATED ALWAYS AS (total_taxable_pay) STORED,
    income_tax NUMERIC(12,2) DEFAULT 0,
    local_income_tax NUMERIC(12,2) DEFAULT 0,

    union_dues NUMERIC(6,2) DEFAULT 0,
    company_loan NUMERIC(12,2) DEFAULT 0,
    other_deductions NUMERIC(12,2) DEFAULT 0,

    -- This column definition remains the same as it calculates total_deductions from non-generated columns.
    total_deductions NUMERIC(12,2) GENERATED ALWAYS AS (
        np_premium + hi_premium + ltc_premium + ei_premium +
        income_tax + local_income_tax + union_dues + company_loan + other_deductions
    ) STORED,

    -- Corrected: net_pay now directly sums/subtracts from the base columns used by total_deductions
    -- instead of referencing total_deductions itself.
    net_pay NUMERIC(12,2) GENERATED ALWAYS AS (
        total_gross_pay -
        (np_premium + hi_premium + ltc_premium + ei_premium +
         income_tax + local_income_tax + union_dues + company_loan + other_deductions)
    ) STORED,

    pay_date DATE,
    payment_status VARCHAR(20) DEFAULT 'pending' CHECK (payment_status IN ('pending', 'paid', 'cancelled')),
    payment_method VARCHAR(20),

    insurance_reported BOOLEAN DEFAULT FALSE,
    report_confirmation_date DATE,

    payslip_issued BOOLEAN DEFAULT FALSE,
    payslip_path VARCHAR(500),

    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(worker_id, pay_year, pay_month)
);

-- monthly_payroll 테이블 코멘트
COMMENT ON TABLE monthly_payroll IS '월별 급여 집계 테이블 (worker_payroll_details에서 자동 집계)';
COMMENT ON COLUMN monthly_payroll.payroll_id IS '월별 급여 기록 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN monthly_payroll.worker_id IS '근로자 ID (workers 테이블 외래키)';
COMMENT ON COLUMN monthly_payroll.pay_year IS '급여 지급 연도';
COMMENT ON COLUMN monthly_payroll.pay_month IS '급여 지급 월';
COMMENT ON COLUMN monthly_payroll.work_days IS '실제 근무일수';
COMMENT ON COLUMN monthly_payroll.total_work_hours IS '총 근무시간';
COMMENT ON COLUMN monthly_payroll.total_gross_pay IS '총 지급액 (과세+비과세, worker_payroll_details에서 자동 집계)';
COMMENT ON COLUMN monthly_payroll.total_taxable_pay IS '총 과세급여 (worker_payroll_details에서 자동 집계)';
COMMENT ON COLUMN monthly_payroll.total_nontax_pay IS '총 비과세급여 (worker_payroll_details에서 자동 집계)';
COMMENT ON COLUMN monthly_payroll.total_tax_excess IS '총 비과세 한도 초과분 (worker_payroll_details에서 자동 집계)';
COMMENT ON COLUMN monthly_payroll.np_standard_income IS '국민연금 기준소득월액 (보험료 계산 기준)';
COMMENT ON COLUMN monthly_payroll.hi_standard_income IS '건강보험 보수월액 (보험료 계산 기준)';
COMMENT ON COLUMN monthly_payroll.ei_standard_income IS '고용보험 보수월액 (보험료 계산 기준)';
COMMENT ON COLUMN monthly_payroll.np_premium IS '국민연금료 (근로자 부담분)';
COMMENT ON COLUMN monthly_payroll.hi_premium IS '건강보험료 (근로자 부담분)';
COMMENT ON COLUMN monthly_payroll.ltc_premium IS '장기요양보험료';
COMMENT ON COLUMN monthly_payroll.ei_premium IS '고용보험료 (근로자 부담분)';
COMMENT ON COLUMN monthly_payroll.income_tax_base IS '소득세 과세표준 (총과세급여, 자동계산)';
COMMENT ON COLUMN monthly_payroll.income_tax IS '소득세 (근로소득세)';
COMMENT ON COLUMN monthly_payroll.local_income_tax IS '지방소득세 (소득세의 10%)';
COMMENT ON COLUMN monthly_payroll.union_dues IS '노조비';
COMMENT ON COLUMN monthly_payroll.company_loan IS '사내대출 상환액';
COMMENT ON COLUMN monthly_payroll.other_deductions IS '기타 공제항목';
COMMENT ON COLUMN monthly_payroll.total_deductions IS '총 공제액 (자동계산)';
COMMENT ON COLUMN monthly_payroll.net_pay IS '실수령액 (자동계산)';
COMMENT ON COLUMN monthly_payroll.pay_date IS '실제 급여 지급일';
COMMENT ON COLUMN monthly_payroll.payment_status IS '지급 상태 (pending:대기, paid:지급완료, cancelled:취소)';
COMMENT ON COLUMN monthly_payroll.payment_method IS '지급 방법 (bank_transfer:계좌이체 등)';
COMMENT ON COLUMN monthly_payroll.insurance_reported IS '4대보험 신고 완료 여부';
COMMENT ON COLUMN monthly_payroll.report_confirmation_date IS '4대보험 신고 확인일';
COMMENT ON COLUMN monthly_payroll.payslip_issued IS '급여명세서 발급 여부';
COMMENT ON COLUMN monthly_payroll.payslip_path IS '급여명세서 파일 경로';
COMMENT ON COLUMN monthly_payroll.created_at IS '레코드 생성일시';

-- ===============================
-- 16. 통합 4대보험 가입 판정 테이블
-- ===============================
CREATE TABLE insurance_eligibility_records (
    eligibility_id SERIAL PRIMARY KEY,
    worker_id INTEGER NOT NULL REFERENCES workers(worker_id),
    
    judgment_type VARCHAR(20) NOT NULL CHECK (judgment_type IN ('immediate', 'monthly', 'rolling_monthly')),
    
    calendar_year_month VARCHAR(7),
    
    rolling_period_start DATE,
    rolling_period_end DATE,
    
    work_days INTEGER NOT NULL DEFAULT 0,
    work_hours DECIMAL(6,2) NOT NULL DEFAULT 0,
    monthly_income NUMERIC(12,2) NOT NULL DEFAULT 0,
    employment_period_months INTEGER DEFAULT 0,
    
    prev_period_work_days INTEGER DEFAULT 0,
    prev_period_work_hours DECIMAL(6,2) DEFAULT 0,
    prev_period_income NUMERIC(12,2) DEFAULT 0,
    
    np_eligible BOOLEAN DEFAULT FALSE,
    hi_eligible BOOLEAN DEFAULT FALSE,
    ei_eligible BOOLEAN DEFAULT FALSE,
    wc_eligible BOOLEAN DEFAULT TRUE,
    
    np_voluntary_eligible BOOLEAN DEFAULT FALSE,
    hi_voluntary_eligible BOOLEAN DEFAULT FALSE,
    ei_voluntary_eligible BOOLEAN DEFAULT FALSE,
    wc_voluntary_eligible BOOLEAN DEFAULT FALSE,
    
    np_reason TEXT,
    hi_reason TEXT,
    ei_reason TEXT,
    wc_reason TEXT,
    
    np_current_status BOOLEAN DEFAULT FALSE,
    hi_current_status BOOLEAN DEFAULT FALSE,
    ei_current_status BOOLEAN DEFAULT FALSE,
    wc_current_status BOOLEAN DEFAULT FALSE,
    
    np_action_required VARCHAR(20) CHECK (np_action_required IN ('none', 'acquire', 'lose', 'voluntary_review')),
    hi_action_required VARCHAR(20) CHECK (hi_action_required IN ('none', 'acquire', 'lose', 'voluntary_review')),
    ei_action_required VARCHAR(20) CHECK (ei_action_required IN ('none', 'acquire', 'lose', 'voluntary_review')),
    wc_action_required VARCHAR(20) CHECK (wc_action_required IN ('none', 'acquire', 'lose', 'voluntary_review')),
    
    processing_status VARCHAR(20) DEFAULT 'pending' CHECK (processing_status IN (
        'pending', 'confirmed', 'processed', 'completed'
    )),
    confirmed_by INTEGER REFERENCES users(user_id),
    confirmed_date DATE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT unique_monthly_judgment UNIQUE (worker_id, calendar_year_month, judgment_type),
    CONSTRAINT unique_rolling_judgment UNIQUE (worker_id, rolling_period_start, judgment_type)
);

-- insurance_eligibility_records 테이블 코멘트
COMMENT ON TABLE insurance_eligibility_records IS '통합 4대보험 가입 판정 테이블 (고용형태별 판정 결과 저장)';
COMMENT ON COLUMN insurance_eligibility_records.eligibility_id IS '4대보험 가입 판정 기록 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN insurance_eligibility_records.worker_id IS '근로자 ID (workers 테이블 외래키)';
COMMENT ON COLUMN insurance_eligibility_records.judgment_type IS '판정 방식 구분 (immediate:즉시, monthly:달력월별, rolling_monthly:입사일기준순환)';
COMMENT ON COLUMN insurance_eligibility_records.calendar_year_month IS '달력월별 판정용 년월 (YYYY-MM 형식, 단시간근로자용)';
COMMENT ON COLUMN insurance_eligibility_records.rolling_period_start IS '입사일 기준 순환 판정 시작일 (일용직용)';
COMMENT ON COLUMN insurance_eligibility_records.rolling_period_end IS '입사일 기준 순환 판정 종료일 (일용직용)';
COMMENT ON COLUMN insurance_eligibility_records.work_days IS '해당 판정기간 중 실제 근무일수';
COMMENT ON COLUMN insurance_eligibility_records.work_hours IS '해당 판정기간 중 총 근무시간';
COMMENT ON COLUMN insurance_eligibility_records.monthly_income IS '해당 판정기간 중 총 소득금액';
COMMENT ON COLUMN insurance_eligibility_records.employment_period_months IS '고용기간 (개월)';
COMMENT ON COLUMN insurance_eligibility_records.prev_period_work_days IS '이전 판정기간 근무일수 (연속성 판단용)';
COMMENT ON COLUMN insurance_eligibility_records.prev_period_work_hours IS '이전 판정기간 근무시간 (연속성 판단용)';
COMMENT ON COLUMN insurance_eligibility_records.prev_period_income IS '이전 판정기간 소득금액 (연속성 판단용)';
COMMENT ON COLUMN insurance_eligibility_records.np_eligible IS '국민연금 의무가입 대상 여부 (시스템 자동 판정 결과)';
COMMENT ON COLUMN insurance_eligibility_records.hi_eligible IS '건강보험 의무가입 대상 여부 (시스템 자동 판정 결과)';
COMMENT ON COLUMN insurance_eligibility_records.ei_eligible IS '고용보험 의무가입 대상 여부 (시스템 자동 판정 결과)';
COMMENT ON COLUMN insurance_eligibility_records.wc_eligible IS '산재보험 의무가입 대상 여부 (기본값 TRUE)';
COMMENT ON COLUMN insurance_eligibility_records.np_voluntary_eligible IS '국민연금 선택가입 가능 여부';
COMMENT ON COLUMN insurance_eligibility_records.hi_voluntary_eligible IS '건강보험 선택가입 가능 여부';
COMMENT ON COLUMN insurance_eligibility_records.ei_voluntary_eligible IS '고용보험 선택가입 가능 여부';
COMMENT ON COLUMN insurance_eligibility_records.wc_voluntary_eligible IS '산재보험 선택가입 가능 여부';
COMMENT ON COLUMN insurance_eligibility_records.np_reason IS '국민연금 판정 근거 및 사유 (가입기준 충족/미충족 상세내용)';
COMMENT ON COLUMN insurance_eligibility_records.hi_reason IS '건강보험 판정 근거 및 사유 (가입기준 충족/미충족 상세내용)';
COMMENT ON COLUMN insurance_eligibility_records.ei_reason IS '고용보험 판정 근거 및 사유 (가입기준 충족/미충족 상세내용)';
COMMENT ON COLUMN insurance_eligibility_records.wc_reason IS '산재보험 판정 근거 및 사유 (가입기준 충족/미충족 상세내용)';
COMMENT ON COLUMN insurance_eligibility_records.np_current_status IS '현재 국민연금 실제 가입 상태 (신고 완료 여부)';
COMMENT ON COLUMN insurance_eligibility_records.hi_current_status IS '현재 건강보험 실제 가입 상태 (신고 완료 여부)';
COMMENT ON COLUMN insurance_eligibility_records.ei_current_status IS '현재 고용보험 실제 가입 상태 (신고 완료 여부)';
COMMENT ON COLUMN insurance_eligibility_records.wc_current_status IS '현재 산재보험 실제 가입 상태 (신고 완료 여부)';
COMMENT ON COLUMN insurance_eligibility_records.np_action_required IS '국민연금 필요 액션 (none:불필요, acquire:취득신고, lose:상실신고, voluntary_review:선택가입검토)';
COMMENT ON COLUMN insurance_eligibility_records.hi_action_required IS '건강보험 필요 액션 (none:불필요, acquire:취득신고, lose:상실신고, voluntary_review:선택가입검토)';
COMMENT ON COLUMN insurance_eligibility_records.ei_action_required IS '고용보험 필요 액션 (none:불필요, acquire:취득신고, lose:상실신고, voluntary_review:선택가입검토)';
COMMENT ON COLUMN insurance_eligibility_records.wc_action_required IS '산재보험 필요 액션 (none:불필요, acquire:취득신고, lose:상실신고, voluntary_review:선택가입검토)';
COMMENT ON COLUMN insurance_eligibility_records.processing_status IS '처리 상태 (pending:대기, confirmed:확인, processed:처리, completed:완료)';
COMMENT ON COLUMN insurance_eligibility_records.confirmed_by IS '판정 결과 확인자 사용자 ID';
COMMENT ON COLUMN insurance_eligibility_records.confirmed_date IS '판정 결과 확인일';
COMMENT ON COLUMN insurance_eligibility_records.created_at IS '레코드 생성일시';
COMMENT ON COLUMN insurance_eligibility_records.updated_at IS '레코드 최종 수정일시';

-- ===============================
-- 17. 4대보험 현재 가입상태 실시간 추적 테이블
-- ===============================
CREATE TABLE current_insurance_status (
    status_id SERIAL PRIMARY KEY,
    worker_id INTEGER NOT NULL REFERENCES workers(worker_id),
    
    np_subscribed BOOLEAN DEFAULT FALSE,
    hi_subscribed BOOLEAN DEFAULT FALSE,
    ei_subscribed BOOLEAN DEFAULT FALSE,
    wc_subscribed BOOLEAN DEFAULT FALSE,
    
    np_subscription_type VARCHAR(20) CHECK (np_subscription_type IN ('mandatory', 'voluntary')),
    hi_subscription_type VARCHAR(20) CHECK (hi_subscription_type IN ('mandatory', 'voluntary')),
    ei_subscription_type VARCHAR(20) CHECK (ei_subscription_type IN ('mandatory', 'voluntary')),
    wc_subscription_type VARCHAR(20) CHECK (wc_subscription_type IN ('mandatory', 'voluntary')),
    
    np_acquisition_date DATE,
    hi_acquisition_date DATE,
    ei_acquisition_date DATE,
    wc_acquisition_date DATE,
    
    np_loss_date DATE,
    hi_loss_date DATE,
    ei_loss_date DATE,
    wc_loss_date DATE,
    
    next_judgment_date DATE,
    
    last_updated TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(worker_id)
);

-- current_insurance_status 테이블 코멘트
COMMENT ON TABLE current_insurance_status IS '4대보험 현재 가입상태 실시간 추적 테이블';
COMMENT ON COLUMN current_insurance_status.status_id IS '보험 가입상태 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN current_insurance_status.worker_id IS '근로자 ID (workers 테이블 외래키, 유니크)';
COMMENT ON COLUMN current_insurance_status.np_subscribed IS '국민연금 현재 가입 상태 (TRUE:가입중, FALSE:미가입)';
COMMENT ON COLUMN current_insurance_status.hi_subscribed IS '건강보험 현재 가입 상태 (TRUE:가입중, FALSE:미가입)';
COMMENT ON COLUMN current_insurance_status.ei_subscribed IS '고용보험 현재 가입 상태 (TRUE:가입중, FALSE:미가입)';
COMMENT ON COLUMN current_insurance_status.wc_subscribed IS '산재보험 현재 가입 상태 (TRUE:가입중, FALSE:미가입)';
COMMENT ON COLUMN current_insurance_status.np_subscription_type IS '국민연금 가입 유형 (mandatory:의무가입, voluntary:선택가입)';
COMMENT ON COLUMN current_insurance_status.hi_subscription_type IS '건강보험 가입 유형 (mandatory:의무가입, voluntary:선택가입)';
COMMENT ON COLUMN current_insurance_status.ei_subscription_type IS '고용보험 가입 유형 (mandatory:의무가입, voluntary:선택가입)';
COMMENT ON COLUMN current_insurance_status.wc_subscription_type IS '산재보험 가입 유형 (mandatory:의무가입, voluntary:선택가입)';
COMMENT ON COLUMN current_insurance_status.np_acquisition_date IS '국민연금 최근 취득일 (가장 최근 가입한 날짜)';
COMMENT ON COLUMN current_insurance_status.hi_acquisition_date IS '건강보험 최근 취득일 (가장 최근 가입한 날짜)';
COMMENT ON COLUMN current_insurance_status.ei_acquisition_date IS '고용보험 최근 취득일 (가장 최근 가입한 날짜)';
COMMENT ON COLUMN current_insurance_status.wc_acquisition_date IS '산재보험 최근 취득일 (가장 최근 가입한 날짜)';
COMMENT ON COLUMN current_insurance_status.np_loss_date IS '국민연금 최근 상실일 (가장 최근 상실한 날짜)';
COMMENT ON COLUMN current_insurance_status.hi_loss_date IS '건강보험 최근 상실일 (가장 최근 상실한 날짜)';
COMMENT ON COLUMN current_insurance_status.ei_loss_date IS '고용보험 최근 상실일 (가장 최근 상실한 날짜)';
COMMENT ON COLUMN current_insurance_status.wc_loss_date IS '산재보험 최근 상실일 (가장 최근 상실한 날짜)';
COMMENT ON COLUMN current_insurance_status.next_judgment_date IS '다음 4대보험 가입 판정 예정일 (일용직 전용)';
COMMENT ON COLUMN current_insurance_status.last_updated IS '상태 정보 최종 업데이트 일시';

-- ===============================
-- 18. 4대보험 취득상실 관리 테이블
-- ===============================
CREATE TABLE insurance_acquisitions_losses (
    record_id SERIAL PRIMARY KEY,
    worker_id INTEGER NOT NULL REFERENCES workers(worker_id),
    company_id INTEGER NOT NULL REFERENCES companies(company_id),
    
    insurance_type VARCHAR(20) NOT NULL CHECK (insurance_type IN ('NP', 'HI', 'EI', 'WC')),
    
    transaction_type VARCHAR(20) NOT NULL CHECK (transaction_type IN ('acquisition', 'loss')),
    
    subscription_type VARCHAR(20) DEFAULT 'mandatory' CHECK (subscription_type IN ('mandatory', 'voluntary')),
    
    effective_date DATE NOT NULL,
    reason_code VARCHAR(10) NOT NULL,
    reason_description TEXT,
    
    standard_income NUMERIC(12,2),
    acquisition_income NUMERIC(12,2),
    
    special_occupation_code CHAR(1) DEFAULT '0',
    pension_system_code CHAR(1) DEFAULT '0',
    premium_reduction_code VARCHAR(5),
    
    voluntary_application_id INTEGER REFERENCES worker_voluntary_insurance(voluntary_id),
    
    report_status VARCHAR(20) DEFAULT 'pending' CHECK (report_status IN (
        'pending', 'reported', 'accepted', 'rejected', 'corrected'
    )),
    report_date DATE,
    report_number VARCHAR(50),
    report_method VARCHAR(20) CHECK (report_method IN ('online', 'visit', 'mail', 'fax')),
    
    report_form_path VARCHAR(500),
    supporting_documents TEXT[],
    
    processing_date DATE,
    processing_notes TEXT,
    rejection_reason TEXT,
    
    prepared_by INTEGER REFERENCES users(user_id),
    reviewed_by INTEGER REFERENCES users(user_id),
    
    auto_generated BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- insurance_acquisitions_losses 테이블 코멘트
COMMENT ON TABLE insurance_acquisitions_losses IS '4대보험 취득상실 신고 관리 테이블 (시스템의 핵심)';
COMMENT ON COLUMN insurance_acquisitions_losses.record_id IS '4대보험 취득상실 기록 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN insurance_acquisitions_losses.worker_id IS '근로자 ID (workers 테이블 외래키)';
COMMENT ON COLUMN insurance_acquisitions_losses.company_id IS '회사 ID (companies 테이블 외래키)';
COMMENT ON COLUMN insurance_acquisitions_losses.insurance_type IS '보험 구분 (NP:국민연금, HI:건강보험, EI:고용보험, WC:산재보험)';
COMMENT ON COLUMN insurance_acquisitions_losses.transaction_type IS '거래 구분 (acquisition:취득, loss:상실)';
COMMENT ON COLUMN insurance_acquisitions_losses.subscription_type IS '가입 유형 (mandatory:의무가입, voluntary:선택가입)';
COMMENT ON COLUMN insurance_acquisitions_losses.effective_date IS '취득일 또는 상실일 (실제 보험 적용일)';
COMMENT ON COLUMN insurance_acquisitions_losses.reason_code IS '취득/상실 사유코드 (보험공단 신고서 기재용)';
COMMENT ON COLUMN insurance_acquisitions_losses.reason_description IS '사유 상세설명 (자동 생성 또는 수동 입력)';
COMMENT ON COLUMN insurance_acquisitions_losses.standard_income IS '기준소득월액 또는 보수월액 (신고서 기재용)';
COMMENT ON COLUMN insurance_acquisitions_losses.acquisition_income IS '취득시 소득월액 (취득 신고 시에만 사용)';
COMMENT ON COLUMN insurance_acquisitions_losses.special_occupation_code IS '특수직종코드 (국민연금, 0:일반, 1:광원, 2:부원)';
COMMENT ON COLUMN insurance_acquisitions_losses.pension_system_code IS '직역연금가입코드 (국민연금, 0:없음, 1:가입자, 2:수급권자)';
COMMENT ON COLUMN insurance_acquisitions_losses.premium_reduction_code IS '보험료 경감코드 (건강보험, 저소득층 등)';
COMMENT ON COLUMN insurance_acquisitions_losses.voluntary_application_id IS '선택가입 신청 ID (선택가입인 경우)';
COMMENT ON COLUMN insurance_acquisitions_losses.report_status IS '신고 상태 (pending:대기, reported:신고완료, accepted:접수, rejected:반려, corrected:정정)';
COMMENT ON COLUMN insurance_acquisitions_losses.report_date IS '실제 신고일 (보험공단에 신고한 날)';
COMMENT ON COLUMN insurance_acquisitions_losses.report_number IS '신고 접수번호 (보험공단에서 부여)';
COMMENT ON COLUMN insurance_acquisitions_losses.report_method IS '신고 방법 (online:온라인, visit:방문, mail:우편, fax:팩스)';
COMMENT ON COLUMN insurance_acquisitions_losses.report_form_path IS '작성된 신고서 파일 저장 경로';
COMMENT ON COLUMN insurance_acquisitions_losses.supporting_documents IS '첨부서류 목록 (파일 경로 배열)';
COMMENT ON COLUMN insurance_acquisitions_losses.processing_date IS '신고 처리완료일 (보험공단 처리일)';
COMMENT ON COLUMN insurance_acquisitions_losses.processing_notes IS '처리 관련 메모 (보험공단 의견 등)';
COMMENT ON COLUMN insurance_acquisitions_losses.rejection_reason IS '반려 사유 (신고가 반려된 경우)';
COMMENT ON COLUMN insurance_acquisitions_losses.prepared_by IS '신고서 작성자 사용자 ID';
COMMENT ON COLUMN insurance_acquisitions_losses.reviewed_by IS '신고서 검토자 사용자 ID';
COMMENT ON COLUMN insurance_acquisitions_losses.auto_generated IS '시스템 자동 생성 여부 (수동/자동 구분)';
COMMENT ON COLUMN insurance_acquisitions_losses.created_at IS '레코드 생성일시';
COMMENT ON COLUMN insurance_acquisitions_losses.updated_at IS '레코드 최종 수정일시';

-- ===============================
-- 19. 4대보험 신고 사유코드 테이블
-- ===============================
CREATE TABLE insurance_reason_codes (
    code_id SERIAL PRIMARY KEY,
    insurance_type VARCHAR(20) NOT NULL CHECK (insurance_type IN ('NP', 'HI', 'EI', 'WC')),
    transaction_type VARCHAR(20) NOT NULL CHECK (transaction_type IN ('acquisition', 'loss')),
    reason_code VARCHAR(10) NOT NULL,
    reason_name VARCHAR(100) NOT NULL,
    description TEXT,
    required_documents TEXT[],
    is_active BOOLEAN DEFAULT TRUE,
    sort_order INTEGER DEFAULT 0,
    
    UNIQUE(insurance_type, transaction_type, reason_code)
);

-- insurance_reason_codes 테이블 코멘트
COMMENT ON TABLE insurance_reason_codes IS '4대보험 취득상실 사유코드 마스터 테이블';
COMMENT ON COLUMN insurance_reason_codes.code_id IS '사유코드 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN insurance_reason_codes.insurance_type IS '보험 구분 (NP:국민연금, HI:건강보험, EI:고용보험, WC:산재보험)';
COMMENT ON COLUMN insurance_reason_codes.transaction_type IS '거래 구분 (acquisition:취득, loss:상실)';
COMMENT ON COLUMN insurance_reason_codes.reason_code IS '사유코드 (신고서 기재용, 예: 10, 20 등)';
COMMENT ON COLUMN insurance_reason_codes.reason_name IS '사유명 (일반취득, 일반상실 등)';
COMMENT ON COLUMN insurance_reason_codes.description IS '사유 상세설명';
COMMENT ON COLUMN insurance_reason_codes.required_documents IS '필요 첨부서류 목록 (배열)';
COMMENT ON COLUMN insurance_reason_codes.is_active IS '현재 사용중인 사유코드 여부';
COMMENT ON COLUMN insurance_reason_codes.sort_order IS '표시 순서 (신고서 작성 시 정렬용)';

-- ===============================
-- 20. 근태 관리 테이블
-- ===============================
CREATE TABLE attendance_records (
    attendance_id SERIAL PRIMARY KEY,
    worker_id INTEGER NOT NULL REFERENCES workers(worker_id),
    work_date DATE NOT NULL,
    
    check_in_time TIME,
    check_out_time TIME,
    break_time_minutes INTEGER DEFAULT 60,
    
    regular_hours DECIMAL(4,2) DEFAULT 0,
    overtime_hours DECIMAL(4,2) DEFAULT 0,
    night_hours DECIMAL(4,2) DEFAULT 0,
    holiday_hours DECIMAL(4,2) DEFAULT 0,
    total_hours DECIMAL(4,2) GENERATED ALWAYS AS (
        regular_hours + overtime_hours + night_hours + holiday_hours
    ) STORED,
    
    attendance_status VARCHAR(20) DEFAULT 'present' CHECK (attendance_status IN (
        'present', 'absent', 'late', 'early_leave', 'sick_leave', 'annual_leave', 'special_leave'
    )),
    
    daily_wage NUMERIC(12,2),
    overtime_pay NUMERIC(12,2) DEFAULT 0,
    night_pay NUMERIC(12,2) DEFAULT 0,
    holiday_pay NUMERIC(12,2) DEFAULT 0,
    total_daily_pay NUMERIC(12,2),
    
    approval_status VARCHAR(20) DEFAULT 'approved' CHECK (approval_status IN ('pending', 'approved', 'rejected')),
    approved_by INTEGER REFERENCES users(user_id),
    approved_date DATE,
    
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(worker_id, work_date)
);

-- attendance_records 테이블 코멘트
COMMENT ON TABLE attendance_records IS '근태 관리 테이블 (4대보험 가입 판단 기준)';
COMMENT ON COLUMN attendance_records.attendance_id IS '근태 기록 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN attendance_records.worker_id IS '근로자 ID (workers 테이블 외래키)';
COMMENT ON COLUMN attendance_records.work_date IS '근무일자';
COMMENT ON COLUMN attendance_records.check_in_time IS '출근 시간';
COMMENT ON COLUMN attendance_records.check_out_time IS '퇴근 시간';
COMMENT ON COLUMN attendance_records.break_time_minutes IS '휴게시간 (분, 기본 60분)';
COMMENT ON COLUMN attendance_records.regular_hours IS '정규근무시간 (기본 8시간 이내)';
COMMENT ON COLUMN attendance_records.overtime_hours IS '연장근무시간 (8시간 초과분)';
COMMENT ON COLUMN attendance_records.night_hours IS '야간근무시간 (22:00~06:00)';
COMMENT ON COLUMN attendance_records.holiday_hours IS '휴일근무시간';
COMMENT ON COLUMN attendance_records.total_hours IS '총 근무시간 (자동 계산)';
COMMENT ON COLUMN attendance_records.attendance_status IS '근태 상태 (present:출근, absent:결근, late:지각, early_leave:조퇴, sick_leave:병가, annual_leave:연차, special_leave:특별휴가)';
COMMENT ON COLUMN attendance_records.daily_wage IS '일당 기본급';
COMMENT ON COLUMN attendance_records.overtime_pay IS '연장근로수당';
COMMENT ON COLUMN attendance_records.night_pay IS '야간근로수당';
COMMENT ON COLUMN attendance_records.holiday_pay IS '휴일근로수당';
COMMENT ON COLUMN attendance_records.total_daily_pay IS '일 총급여 (일당 + 각종 수당)';
COMMENT ON COLUMN attendance_records.approval_status IS '승인 상태 (pending:대기, approved:승인, rejected:반려)';
COMMENT ON COLUMN attendance_records.approved_by IS '승인자 사용자 ID';
COMMENT ON COLUMN attendance_records.approved_date IS '승인일';
COMMENT ON COLUMN attendance_records.notes IS '근태 관련 메모';
COMMENT ON COLUMN attendance_records.created_at IS '레코드 생성일시';

-- ===============================
-- 21. 일용직 연속 근무 추적 테이블 (핵심)
-- ===============================
CREATE TABLE daily_worker_continuous_periods (
    period_id SERIAL PRIMARY KEY,
    worker_id INTEGER NOT NULL REFERENCES workers(worker_id),
    
    continuous_start_date DATE NOT NULL,
    continuous_end_date DATE,
    
    total_work_days INTEGER DEFAULT 0,
    total_work_hours DECIMAL(8,2) DEFAULT 0,
    total_work_income NUMERIC(12,2) DEFAULT 0,
    
    np_acquired_date DATE,
    hi_acquired_date DATE,
    ei_acquired_date DATE,
    wc_acquired_date DATE,
    
    np_lost_date DATE,
    hi_lost_date DATE,
    ei_lost_date DATE,
    wc_lost_date DATE,
    
    is_active BOOLEAN DEFAULT TRUE,
    
    auto_calculated BOOLEAN DEFAULT TRUE,
    last_calculation_date DATE DEFAULT CURRENT_DATE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- daily_worker_continuous_periods 테이블 코멘트
COMMENT ON TABLE daily_worker_continuous_periods IS '일용직 연속 근무 기간 추적 테이블 (4대보험 가입 판정용, 롤링 월별 판정 핵심)';
COMMENT ON COLUMN daily_worker_continuous_periods.period_id IS '연속 근무 기간 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN daily_worker_continuous_periods.worker_id IS '근로자 ID (어느 일용직 근로자의 연속 근무 기간인지)';
COMMENT ON COLUMN daily_worker_continuous_periods.continuous_start_date IS '연속 근무 시작일 (해당 현장/회사에서 첫 근무일, 중단없이 계속 근무한 시작점)';
COMMENT ON COLUMN daily_worker_continuous_periods.continuous_end_date IS '연속 근무 종료일 (NULL이면 현재도 연속 근무중)';
COMMENT ON COLUMN daily_worker_continuous_periods.total_work_days IS '해당 연속기간 중 총 실제 근무일수 (휴일 제외)';
COMMENT ON COLUMN daily_worker_continuous_periods.total_work_hours IS '해당 연속기간 중 총 근무시간 (시간 단위)';
COMMENT ON COLUMN daily_worker_continuous_periods.total_work_income IS '해당 연속기간 중 총 급여수입 (원)';
COMMENT ON COLUMN daily_worker_continuous_periods.np_acquired_date IS '국민연금 취득일 (해당 연속기간 중 가입한 날)';
COMMENT ON COLUMN daily_worker_continuous_periods.hi_acquired_date IS '건강보험 취득일 (해당 연속기간 중 가입한 날)';
COMMENT ON COLUMN daily_worker_continuous_periods.ei_acquired_date IS '고용보험 취득일 (해당 연속기간 중 가입한 날)';
COMMENT ON COLUMN daily_worker_continuous_periods.wc_acquired_date IS '산재보험 취득일 (해당 연속기간 중 가입한 날)';
COMMENT ON COLUMN daily_worker_continuous_periods.np_lost_date IS '국민연금 상실일 (해당 연속기간 중 상실한 날)';
COMMENT ON COLUMN daily_worker_continuous_periods.hi_lost_date IS '건강보험 상실일 (해당 연속기간 중 상실한 날)';
COMMENT ON COLUMN daily_worker_continuous_periods.ei_lost_date IS '고용보험 상실일 (해당 연속기간 중 상실한 날)';
COMMENT ON COLUMN daily_worker_continuous_periods.wc_lost_date IS '산재보험 상실일 (해당 연속기간 중 상실한 날)';
COMMENT ON COLUMN daily_worker_continuous_periods.is_active IS '현재 유효한 연속기간 여부 (TRUE:현재 진행중, FALSE:종료됨)';
COMMENT ON COLUMN daily_worker_continuous_periods.auto_calculated IS '자동 계산 여부 (TRUE:시스템자동계산, FALSE:수동입력)';
COMMENT ON COLUMN daily_worker_continuous_periods.last_calculation_date IS '마지막 계산일 (배치 처리 시 업데이트)';
COMMENT ON COLUMN daily_worker_continuous_periods.created_at IS '연속 근무 기간 레코드 생성일시';
COMMENT ON COLUMN daily_worker_continuous_periods.updated_at IS '연속 근무 기간 레코드 최종 수정일시';

-- ===============================
-- 22. 배치 처리 로그 테이블 (신규 추가)
-- ===============================
CREATE TABLE batch_processing_logs (
    log_id SERIAL PRIMARY KEY,
    batch_type VARCHAR(30) NOT NULL CHECK (batch_type IN (
        'daily_rolling_monthly', 'monthly_insurance', 'quarterly_insurance', 
        'continuous_period_update', 'auto_eligibility_check'
    )),
    batch_date DATE NOT NULL,
    execution_start_time TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    execution_end_time TIMESTAMP WITH TIME ZONE,
    
    total_workers_processed INTEGER DEFAULT 0,
    successful_processes INTEGER DEFAULT 0,
    failed_processes INTEGER DEFAULT 0,
    
    processing_status VARCHAR(20) DEFAULT 'running' CHECK (processing_status IN ('running', 'completed', 'failed', 'partial')),
    
    error_messages TEXT[],
    processing_notes TEXT,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- batch_processing_logs 테이블 코멘트
COMMENT ON TABLE batch_processing_logs IS '배치 처리 로그 테이블 (일일 롤링 월별 판정 등 자동화 작업 추적)';
COMMENT ON COLUMN batch_processing_logs.log_id IS '배치 처리 로그 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN batch_processing_logs.batch_type IS '배치 작업 유형 (daily_rolling_monthly:일일롤링월별판정, monthly_insurance:월별보험처리, quarterly_insurance:분기별보험처리, continuous_period_update:연속근무기간업데이트, auto_eligibility_check:자동자격판정)';
COMMENT ON COLUMN batch_processing_logs.batch_date IS '배치 처리 대상 날짜 (어느 날의 데이터를 처리했는지)';
COMMENT ON COLUMN batch_processing_logs.execution_start_time IS '배치 시작 시간';
COMMENT ON COLUMN batch_processing_logs.execution_end_time IS '배치 종료 시간';
COMMENT ON COLUMN batch_processing_logs.total_workers_processed IS '처리된 총 근로자 수';
COMMENT ON COLUMN batch_processing_logs.successful_processes IS '성공적으로 처리된 근로자 수';
COMMENT ON COLUMN batch_processing_logs.failed_processes IS '처리 실패한 근로자 수';
COMMENT ON COLUMN batch_processing_logs.processing_status IS '배치 처리 상태 (running:실행중, completed:완료, failed:실패, partial:부분성공)';
COMMENT ON COLUMN batch_processing_logs.error_messages IS '오류 메시지 배열 (실패한 경우 상세 내용)';
COMMENT ON COLUMN batch_processing_logs.processing_notes IS '처리 관련 메모 (특이사항, 주의사항 등)';
COMMENT ON COLUMN batch_processing_logs.created_at IS '로그 생성일시';

-- ===============================
-- 23. 신고 일정 관리 테이블
-- ===============================
CREATE TABLE report_schedules (
    schedule_id SERIAL PRIMARY KEY,
    company_id INTEGER NOT NULL REFERENCES companies(company_id),
    
    report_type VARCHAR(30) NOT NULL CHECK (report_type IN (
        'monthly_insurance', 'quarterly_insurance', 'annual_insurance',
        'acquisition_loss', 'payroll_report', 'employment_insurance_report'
    )),
    report_title VARCHAR(200) NOT NULL,
    
    report_year INTEGER NOT NULL,
    report_month INTEGER,
    target_period_start DATE,
    target_period_end DATE,
    
    due_date DATE NOT NULL,
    extended_due_date DATE,
    
    report_status VARCHAR(20) DEFAULT 'pending' CHECK (report_status IN (
        'pending', 'in_progress', 'completed', 'overdue', 'extended'
    )),
    completion_date DATE,
    
    assigned_to INTEGER REFERENCES users(user_id),
    
    reminder_days INTEGER DEFAULT 7,
    reminder_sent BOOLEAN DEFAULT FALSE,
    
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- report_schedules 테이블 코멘트
COMMENT ON TABLE report_schedules IS '4대보험 및 각종 신고 일정 관리 테이블 (마감일 관리)';
COMMENT ON COLUMN report_schedules.schedule_id IS '신고 일정 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN report_schedules.company_id IS '대상 회사 ID (어느 회사의 신고인지)';
COMMENT ON COLUMN report_schedules.report_type IS '신고 유형 (monthly_insurance:월별4대보험, quarterly_insurance:분기별보험, annual_insurance:연간보험, acquisition_loss:취득상실, payroll_report:급여신고, employment_insurance_report:고용보험신고)';
COMMENT ON COLUMN report_schedules.report_title IS '신고 제목 (예: 2024년 1월 4대보험 취득상실신고)';
COMMENT ON COLUMN report_schedules.report_year IS '신고 대상 연도';
COMMENT ON COLUMN report_schedules.report_month IS '신고 대상 월 (해당되는 경우)';
COMMENT ON COLUMN report_schedules.target_period_start IS '신고 대상 기간 시작일';
COMMENT ON COLUMN report_schedules.target_period_end IS '신고 대상 기간 종료일';
COMMENT ON COLUMN report_schedules.due_date IS '신고 마감일 (법정 신고기한)';
COMMENT ON COLUMN report_schedules.extended_due_date IS '연장신고 기한 (연장 승인된 경우)';
COMMENT ON COLUMN report_schedules.report_status IS '신고 상태 (pending:대기, in_progress:진행중, completed:완료, overdue:연체, extended:연장신고)';
COMMENT ON COLUMN report_schedules.completion_date IS '신고 완료일 (실제로 신고를 완료한 날)';
COMMENT ON COLUMN report_schedules.assigned_to IS '담당 직원 사용자 ID (누가 담당하는지)';
COMMENT ON COLUMN report_schedules.reminder_days IS '마감 몇 일 전 알림 (기본 7일, 미리 알림용)';
COMMENT ON COLUMN report_schedules.reminder_sent IS '알림 발송 여부 (TRUE:발송완료, FALSE:미발송)';
COMMENT ON COLUMN report_schedules.notes IS '신고 관련 메모 (특이사항, 주의사항 등)';
COMMENT ON COLUMN report_schedules.created_at IS '신고 일정 등록일시';

-- ===============================
-- 24. 클라이언트 서비스 현황 테이블
-- ===============================
CREATE TABLE client_services (
    service_id SERIAL PRIMARY KEY,
    company_id INTEGER NOT NULL REFERENCES companies(company_id),
    service_month VARCHAR(7) NOT NULL,
    
    total_workers INTEGER NOT NULL DEFAULT 0,
    new_hires INTEGER DEFAULT 0,
    resignations INTEGER DEFAULT 0,
    
    np_acquisitions INTEGER DEFAULT 0,
    np_losses INTEGER DEFAULT 0,
    hi_acquisitions INTEGER DEFAULT 0,
    hi_losses INTEGER DEFAULT 0,
    ei_acquisitions INTEGER DEFAULT 0,
    ei_losses INTEGER DEFAULT 0,
    wc_acquisitions INTEGER DEFAULT 0,
    wc_losses INTEGER DEFAULT 0,
    
    payroll_processed BOOLEAN DEFAULT FALSE,
    payroll_amount NUMERIC(15,2) DEFAULT 0,
    total_insurance_premium NUMERIC(12,2) DEFAULT 0,
    
    consultation_hours DECIMAL(4,1) DEFAULT 0,
    document_preparation_count INTEGER DEFAULT 0,
    site_visit_count INTEGER DEFAULT 0,
    
    monthly_service_fee NUMERIC(12,2),
    additional_charges NUMERIC(12,2) DEFAULT 0,
    total_charges NUMERIC(12,2),
    
    primary_staff_id INTEGER REFERENCES labor_office_staff(staff_id),
    secondary_staff_id INTEGER REFERENCES labor_office_staff(staff_id),
    
    service_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(company_id, service_month)
);

-- client_services 테이블 코멘트
COMMENT ON TABLE client_services IS '클라이언트별 월간 서비스 현황 및 수수료 관리 테이블';
COMMENT ON COLUMN client_services.service_id IS '서비스 현황 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN client_services.company_id IS '클라이언트 회사 ID (어느 회사에 대한 서비스인지)';
COMMENT ON COLUMN client_services.service_month IS '서비스 제공 월 (YYYY-MM 형식)';
COMMENT ON COLUMN client_services.total_workers IS '해당월 총 근로자 수';
COMMENT ON COLUMN client_services.new_hires IS '해당월 신규 입사자 수';
COMMENT ON COLUMN client_services.resignations IS '해당월 퇴사자 수';
COMMENT ON COLUMN client_services.np_acquisitions IS '해당월 국민연금 취득 신고건수';
COMMENT ON COLUMN client_services.np_losses IS '해당월 국민연금 상실 신고건수';
COMMENT ON COLUMN client_services.hi_acquisitions IS '해당월 건강보험 취득 신고건수';
COMMENT ON COLUMN client_services.hi_losses IS '해당월 건강보험 상실 신고건수';
COMMENT ON COLUMN client_services.ei_acquisitions IS '해당월 고용보험 취득 신고건수';
COMMENT ON COLUMN client_services.ei_losses IS '해당월 고용보험 상실 신고건수';
COMMENT ON COLUMN client_services.wc_acquisitions IS '해당월 산재보험 취득 신고건수';
COMMENT ON COLUMN client_services.wc_losses IS '해당월 산재보험 상실 신고건수';
COMMENT ON COLUMN client_services.payroll_processed IS '해당월 급여계산 처리 여부 (TRUE:처리완료, FALSE:미처리)';
COMMENT ON COLUMN client_services.payroll_amount IS '해당월 총 급여 지급액 (원)';
COMMENT ON COLUMN client_services.total_insurance_premium IS '해당월 총 4대보험료 (근로자+사업주 부담분 합계)';
COMMENT ON COLUMN client_services.consultation_hours IS '해당월 상담 시간 (시간 단위)';
COMMENT ON COLUMN client_services.document_preparation_count IS '해당월 서류 작성 건수 (신고서, 계약서 등)';
COMMENT ON COLUMN client_services.site_visit_count IS '해당월 현장 방문 횟수';
COMMENT ON COLUMN client_services.monthly_service_fee IS '해당월 서비스 기본료 (계약된 월 고정비)';
COMMENT ON COLUMN client_services.additional_charges IS '해당월 추가 비용 (건별 수수료, 특별 서비스 등)';
COMMENT ON COLUMN client_services.total_charges IS '해당월 총 청구금액 (기본료 + 추가비용)';
COMMENT ON COLUMN client_services.primary_staff_id IS '주담당자 직원 ID (메인으로 서비스하는 직원)';
COMMENT ON COLUMN client_services.secondary_staff_id IS '부담당자 직원 ID (보조로 서비스하는 직원)';
COMMENT ON COLUMN client_services.service_notes IS '해당월 서비스 관련 특이사항 및 메모';
COMMENT ON COLUMN client_services.created_at IS '서비스 현황 등록일시';

-- ===============================
-- 25. 급여명세서 템플릿 관리 테이블
-- ===============================
CREATE TABLE payslip_templates (
    template_id SERIAL PRIMARY KEY,
    company_id INTEGER REFERENCES companies(company_id),
    template_name VARCHAR(100) NOT NULL,
    template_type VARCHAR(20) NOT NULL CHECK (template_type IN ('standard', 'simple', 'detailed')),
    
    show_nontax_details BOOLEAN DEFAULT TRUE,
    show_insurance_details BOOLEAN DEFAULT TRUE,
    show_tax_calculation BOOLEAN DEFAULT FALSE,
    show_attendance_summary BOOLEAN DEFAULT TRUE,
    
    display_items JSONB,
    
    template_file_path VARCHAR(500),
    header_logo_path VARCHAR(500),
    footer_text TEXT,
    
    is_default BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- payslip_templates 테이블 코멘트
COMMENT ON TABLE payslip_templates IS '급여명세서 템플릿 관리 테이블 (회사별 맞춤 설정)';
COMMENT ON COLUMN payslip_templates.template_id IS '급여명세서 템플릿 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN payslip_templates.company_id IS '적용 회사 ID (어느 회사의 템플릿인지, NULL이면 공통 템플릿)';
COMMENT ON COLUMN payslip_templates.template_name IS '템플릿명 (건설업 표준, 제조업 간소, 서비스업 상세 등)';
COMMENT ON COLUMN payslip_templates.template_type IS '템플릿 유형 (standard:표준형, simple:간소형, detailed:상세형)';
COMMENT ON COLUMN payslip_templates.show_nontax_details IS '비과세 항목 상세 표시 여부 (TRUE:상세표시, FALSE:합계만)';
COMMENT ON COLUMN payslip_templates.show_insurance_details IS '4대보험 상세 표시 여부 (TRUE:상세표시, FALSE:합계만)';
COMMENT ON COLUMN payslip_templates.show_tax_calculation IS '세금 계산 과정 표시 여부 (TRUE:계산과정표시, FALSE:결과만)';
COMMENT ON COLUMN payslip_templates.show_attendance_summary IS '근태 요약 표시 여부 (TRUE:표시, FALSE:숨김)';
COMMENT ON COLUMN payslip_templates.display_items IS '급여명세서 표시 항목 설정 JSON (어떤 항목을 표시할지 세부 설정)';
COMMENT ON COLUMN payslip_templates.template_file_path IS '템플릿 파일 저장 경로 (실제 서식 파일 위치)';
COMMENT ON COLUMN payslip_templates.header_logo_path IS '회사 로고 이미지 파일 경로 (급여명세서 상단 로고)';
COMMENT ON COLUMN payslip_templates.footer_text IS '급여명세서 하단 문구 (회사 공지사항, 주의사항 등)';
COMMENT ON COLUMN payslip_templates.is_default IS '기본 템플릿 여부 (TRUE:기본템플릿, FALSE:추가템플릿, 회사별 하나만 기본값)';
COMMENT ON COLUMN payslip_templates.is_active IS '현재 사용중인 템플릿 여부 (TRUE:사용중, FALSE:사용안함)';
COMMENT ON COLUMN payslip_templates.created_at IS '템플릿 생성일시';

-- ===============================
-- 26. 근로소득 원천징수영수증 관리 테이블
-- ===============================
CREATE TABLE income_tax_withholding (
    withholding_id SERIAL PRIMARY KEY,
    worker_id INTEGER NOT NULL REFERENCES workers(worker_id),
    tax_year INTEGER NOT NULL,

    total_income NUMERIC(12,2) NOT NULL DEFAULT 0,
    nontax_income NUMERIC(12,2) DEFAULT 0,
    taxable_income NUMERIC(12,2) GENERATED ALWAYS AS (total_income - nontax_income) STORED,

    basic_deduction NUMERIC(12,2) DEFAULT 0,
    personal_deduction NUMERIC(12,2) DEFAULT 0,
    insurance_premium_deduction NUMERIC(12,2) DEFAULT 0,
    other_deductions NUMERIC(12,2) DEFAULT 0,
    total_deductions NUMERIC(12,2) GENERATED ALWAYS AS (
        basic_deduction + personal_deduction + insurance_premium_deduction + other_deductions
    ) STORED,

    -- Corrected: taxable_base now directly references non-generated columns
    taxable_base NUMERIC(12,2) GENERATED ALWAYS AS (
        GREATEST(
            (total_income - nontax_income) - -- Replaced taxable_income with its definition
            (basic_deduction + personal_deduction + insurance_premium_deduction + other_deductions), -- Replaced total_deductions with its definition
            0
        )
    ) STORED,
    calculated_tax NUMERIC(12,2) DEFAULT 0,
    tax_credits NUMERIC(12,2) DEFAULT 0,
    determined_tax NUMERIC(12,2) GENERATED ALWAYS AS (
        GREATEST(calculated_tax - tax_credits, 0)
    ) STORED,

    withheld_income_tax NUMERIC(12,2) DEFAULT 0,
    withheld_local_tax NUMERIC(12,2) DEFAULT 0,

    -- Corrected: final_tax_amount now directly references determined_tax (which itself is generated)
    -- This specific case for determined_tax referencing other generated columns is fine
    -- because determined_tax is calculated *before* final_tax_amount in the table definition.
    -- The rule is "a generated column cannot reference *another* generated column that is *defined later* in the same table, or form a cyclic dependency."
    -- Here, determined_tax is already defined when final_tax_amount tries to use it.
    final_tax_amount NUMERIC(12,2) GENERATED ALWAYS AS (
        GREATEST(calculated_tax - tax_credits, 0) - withheld_income_tax -- Replaced determined_tax with its definition
    ) STORED,
    -- Corrected: final_local_tax_amount now directly references determined_tax (which itself is generated)
    final_local_tax_amount NUMERIC(12,2) GENERATED ALWAYS AS (
        (GREATEST(calculated_tax - tax_credits, 0) * 0.1) - withheld_local_tax -- Replaced determined_tax with its definition
    ) STORED,

    issued_date DATE,
    issued_by INTEGER REFERENCES users(user_id),
    certificate_number VARCHAR(50),

    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- income_tax_withholding 테이블 코멘트
COMMENT ON TABLE income_tax_withholding IS '근로소득 원천징수영수증 관리 테이블 (연말정산 대비)';
COMMENT ON COLUMN income_tax_withholding.withholding_id IS '원천징수영수증 고유 식별자 (자동증가 기본키)';
COMMENT ON COLUMN income_tax_withholding.worker_id IS '근로자 ID (누구의 원천징수영수증인지)';
COMMENT ON COLUMN income_tax_withholding.tax_year IS '소득 귀속 연도 (어느 연도 소득에 대한 것인지)';
COMMENT ON COLUMN income_tax_withholding.total_income IS '연간 총급여액 (과세소득 + 비과세소득)';
COMMENT ON COLUMN income_tax_withholding.nontax_income IS '연간 비과세소득 합계 (식대, 교통비 등)';
COMMENT ON COLUMN income_tax_withholding.taxable_income IS '연간 과세소득 (총급여 - 비과세소득, 자동계산)';
COMMENT ON COLUMN income_tax_withholding.basic_deduction IS '근로소득공제 (과세소득 구간별 자동계산)';
COMMENT ON COLUMN income_tax_withholding.personal_deduction IS '인적공제 (본인 150만원 + 부양가족공제)';
COMMENT ON COLUMN income_tax_withholding.insurance_premium_deduction IS '4대보험료 소득공제 (근로자 부담분)';
COMMENT ON COLUMN income_tax_withholding.other_deductions IS '기타 소득공제 (연금저축, 주택자금, 교육비 등)';
COMMENT ON COLUMN income_tax_withholding.total_deductions IS '총 소득공제액 (모든 공제 합계, 자동계산)';
COMMENT ON COLUMN income_tax_withholding.taxable_base IS '과세표준 (과세소득 - 소득공제, 자동계산)';
COMMENT ON COLUMN income_tax_withholding.calculated_tax IS '산출세액 (과세표준에 세율 적용한 세액)';
COMMENT ON COLUMN income_tax_withholding.tax_credits IS '세액공제 (자녀세액공제, 연말정산세액공제 등)';
COMMENT ON COLUMN income_tax_withholding.determined_tax IS '결정세액 (산출세액 - 세액공제, 자동계산)';
COMMENT ON COLUMN income_tax_withholding.withheld_income_tax IS '기납부 소득세 (연간 원천징수된 소득세 합계)';
COMMENT ON COLUMN income_tax_withholding.withheld_local_tax IS '기납부 지방소득세 (연간 원천징수된 지방소득세 합계)';
COMMENT ON COLUMN income_tax_withholding.final_tax_amount IS '차감납부할 소득세 (결정세액 - 기납부세액, 자동계산)';
COMMENT ON COLUMN income_tax_withholding.final_local_tax_amount IS '차감납부할 지방소득세 (결정세액의 10% - 기납부지방세, 자동계산)';
COMMENT ON COLUMN income_tax_withholding.issued_date IS '원천징수영수증 발급일';
COMMENT ON COLUMN income_tax_withholding.issued_by IS '발급자 사용자 ID (누가 발급했는지)';
COMMENT ON COLUMN income_tax_withholding.certificate_number IS '원천징수영수증 일련번호 (관리용 고유번호)';
COMMENT ON COLUMN income_tax_withholding.created_at IS '원천징수영수증 생성일시';

-- ===============================
-- 외래키 제약조건 설정
-- ===============================
ALTER TABLE user_roles ADD CONSTRAINT fk_scope_company FOREIGN KEY (scope_company_id) REFERENCES companies(company_id);
ALTER TABLE user_roles ADD CONSTRAINT fk_scope_department FOREIGN KEY (scope_department_id) REFERENCES departments(department_id);
ALTER TABLE user_roles ADD CONSTRAINT fk_scope_labor_office FOREIGN KEY (scope_labor_office_id) REFERENCES labor_offices(labor_office_id);






-- ===============================
-- 4대보험 시스템 통일된 엔터티 상태 관리 시스템 (수정된 완전 버전)
-- 야해마트 상태 변경 문제 해결 포함
-- ===============================

-- ===============================
-- 1. 테이블 스키마 수정 (상태값 통일)
-- ===============================

-- 1-1. 노무사 사무실 상태 통일
ALTER TABLE labor_offices 
    DROP CONSTRAINT IF EXISTS labor_offices_office_status_check;

ALTER TABLE labor_offices 
    ADD CONSTRAINT labor_offices_office_status_check 
    CHECK (office_status IN ('active', 'inactive', 'terminated'));

-- 기존 데이터 마이그레이션
UPDATE labor_offices SET 
    office_status = CASE 
        WHEN office_status = 'suspended' THEN 'inactive'
        WHEN office_status = 'closed' THEN 'terminated'
        ELSE 'active'
    END;

-- 1-2. 회사 상태 통일
UPDATE companies SET 
    client_status = CASE 
        WHEN client_status = 'suspended' THEN 'inactive'
        ELSE client_status
    END;

-- 1-3. 근로자 상태 통일
ALTER TABLE workers 
    DROP CONSTRAINT IF EXISTS workers_employment_status_check;

ALTER TABLE workers 
    ADD CONSTRAINT workers_employment_status_check 
    CHECK (employment_status IN ('active', 'inactive', 'terminated'));

-- 기존 데이터 마이그레이션
UPDATE workers SET 
    employment_status = CASE 
        WHEN employment_status = 'suspended' THEN 'inactive'
        WHEN employment_status = 'resigned' THEN 'terminated'
        ELSE 'active'
    END;

-- 1-4. 노무사 직원 상태 통일
UPDATE labor_office_staff SET 
    employment_status = CASE 
        WHEN employment_status = 'suspended' THEN 'inactive'
        ELSE employment_status
    END;

-- 1-5. 사용자 상태 통일 (is_active와 user_status 통합)
-- 기존 BOOLEAN is_active를 VARCHAR user_status로 통합
ALTER TABLE users ADD COLUMN IF NOT EXISTS user_status VARCHAR(20) DEFAULT 'active';

-- 기존 데이터 마이그레이션 (is_active 기준)
UPDATE users SET 
    user_status = CASE 
        WHEN is_active = TRUE THEN 'active'
        ELSE 'inactive'
    END
WHERE user_status IS NULL OR user_status = '';

-- 제약 조건 추가
ALTER TABLE users 
    DROP CONSTRAINT IF EXISTS users_user_status_check;
    
ALTER TABLE users 
    ADD CONSTRAINT users_user_status_check 
    CHECK (user_status IN ('active', 'inactive', 'terminated'));

-- is_active 컬럼과 user_status 동기화 (기존 호환성 유지)
UPDATE users SET is_active = (user_status = 'active');

-- ===============================
-- 2. 핵심 RLS 헬퍼 함수들 (실제 구현 버전)
-- ===============================

-- 2-1. 현재 사용자 ID 조회 함수 (RLS 핵심)
CREATE OR REPLACE FUNCTION get_current_user_id()
RETURNS INTEGER AS $$
BEGIN
    RETURN COALESCE(current_setting('app.current_user_id', true)::INTEGER, 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-2. 사용자 컨텍스트 설정 함수
CREATE OR REPLACE FUNCTION set_current_user_context(user_id_param INTEGER)
RETURNS VOID AS $$
BEGIN
    PERFORM set_config('app.current_user_id', user_id_param::TEXT, false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-3. 컨텍스트 정리 함수
CREATE OR REPLACE FUNCTION clear_user_context()
RETURNS VOID AS $$
BEGIN
    PERFORM set_config('app.current_user_id', '', false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-4. 역할 확인 함수 (RLS 핵심)
CREATE OR REPLACE FUNCTION user_has_role(role_code_param TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 
        FROM user_roles ur
        JOIN roles r ON ur.role_id = r.role_id
        WHERE ur.user_id = get_current_user_id()
          AND r.role_code = role_code_param
          AND ur.is_active = true
          AND (ur.end_date IS NULL OR ur.end_date >= CURRENT_DATE)
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-5. SUPER_ADMIN 확인 함수
CREATE OR REPLACE FUNCTION is_super_admin()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN user_has_role('SUPER_ADMIN');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 호환성을 위한 별칭
CREATE OR REPLACE FUNCTION is_system_admin()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN is_super_admin();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-6. 노무사/회사 멤버 확인 함수
CREATE OR REPLACE FUNCTION is_labor_office_member()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN user_has_role('LABOR_ADMIN') OR user_has_role('LABOR_STAFF');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION is_company_member()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN user_has_role('COMPANY_ADMIN') OR user_has_role('COMPANY_HR');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-7. 소속 정보 조회 함수들
CREATE OR REPLACE FUNCTION get_user_labor_office_id()
RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT los.labor_office_id
        FROM labor_office_staff los
        WHERE los.user_id = get_current_user_id()
          AND los.employment_status = 'active'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION get_user_company_id()
RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT d.company_id
        FROM user_department_assignments uda
        JOIN departments d ON uda.department_id = d.department_id
        WHERE uda.user_id = get_current_user_id()
          AND uda.is_active = true
          AND (uda.end_date IS NULL OR uda.end_date >= CURRENT_DATE)
        LIMIT 1
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-8. 회사 접근 권한 확인 함수 (RLS 핵심)
CREATE OR REPLACE FUNCTION user_can_access_company(company_id_param INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    -- 노무사 사무실 직원인 경우: 담당 회사 확인
    IF is_labor_office_member() THEN
        RETURN EXISTS (
            SELECT 1 
            FROM user_company_assignments uca
            WHERE uca.user_id = get_current_user_id()
              AND uca.company_id = company_id_param
              AND uca.is_active = true
              AND (uca.end_date IS NULL OR uca.end_date >= CURRENT_DATE)
        );
    END IF;
    
    -- 회사 직원인 경우: 자신의 회사만
    IF is_company_member() THEN
        RETURN get_user_company_id() = company_id_param;
    END IF;
    
    RETURN false;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-9. 부서 접근 권한 확인 함수
CREATE OR REPLACE FUNCTION user_can_access_department(department_id_param INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
    dept_company_id INTEGER;
BEGIN
    SELECT company_id INTO dept_company_id
    FROM departments
    WHERE department_id = department_id_param;
    
    RETURN user_can_access_company(dept_company_id);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-10. 현재 사용자 권한 정보 조회
CREATE OR REPLACE FUNCTION get_current_user_permissions()
RETURNS TABLE (
    user_id INTEGER,
    username TEXT,
    roles TEXT[],
    labor_office_id INTEGER,
    company_id INTEGER,
    accessible_companies INTEGER[]
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.user_id,
        u.username::TEXT,
        ARRAY(
            SELECT r.role_code::TEXT
            FROM user_roles ur 
            JOIN roles r ON ur.role_id = r.role_id 
            WHERE ur.user_id = get_current_user_id() 
              AND ur.is_active = true
        ) as roles,
        get_user_labor_office_id() as labor_office_id,
        get_user_company_id() as company_id,
        ARRAY(
            SELECT uca.company_id 
            FROM user_company_assignments uca 
            WHERE uca.user_id = get_current_user_id() 
              AND uca.is_active = true
        ) as accessible_companies
    FROM users u
    WHERE u.user_id = get_current_user_id();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===============================
-- 3. 통일된 상태 확인 뷰 생성
-- ===============================

CREATE OR REPLACE VIEW unified_entity_status AS
SELECT 
    'labor_office' as entity_type,
    labor_office_id as entity_id,
    office_name as entity_name,
    office_status as status,
    NULL as parent_entity_type,
    NULL as parent_entity_id,
    NULL as parent_status
FROM labor_offices

UNION ALL

SELECT 
    'company' as entity_type,
    company_id as entity_id,
    company_name as entity_name,
    client_status as status,
    'labor_office' as parent_entity_type,
    labor_office_id as parent_entity_id,
    (SELECT office_status FROM labor_offices lo WHERE lo.labor_office_id = companies.labor_office_id) as parent_status
FROM companies

UNION ALL

SELECT 
    'worker' as entity_type,
    worker_id as entity_id,
    name as entity_name,
    employment_status as status,
    'company' as parent_entity_type,
    company_id as parent_entity_id,
    (SELECT client_status FROM companies c WHERE c.company_id = workers.company_id) as parent_status
FROM workers

UNION ALL

SELECT 
    'labor_staff' as entity_type,
    staff_id as entity_id,
    (SELECT name FROM users u WHERE u.user_id = labor_office_staff.user_id) as entity_name,
    employment_status as status,
    'labor_office' as parent_entity_type,
    labor_office_id as parent_entity_id,
    (SELECT office_status FROM labor_offices lo WHERE lo.labor_office_id = labor_office_staff.labor_office_id) as parent_status
FROM labor_office_staff

UNION ALL

SELECT 
    'user' as entity_type,
    user_id as entity_id,
    username as entity_name,
    user_status as status,
    NULL as parent_entity_type,
    NULL as parent_entity_id,
    NULL as parent_status
FROM users;

-- ===============================
-- 4. 통일된 상태 관리 함수들
-- ===============================

-- 4-1. 유효한 상태값 검증 함수
CREATE OR REPLACE FUNCTION is_valid_status(p_status VARCHAR(20))
RETURNS BOOLEAN AS $$
BEGIN
    RETURN p_status IN ('active', 'inactive', 'terminated');
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- 4-2. 엔터티별 효과적 상태 계산 함수
CREATE OR REPLACE FUNCTION get_effective_status(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER
) RETURNS VARCHAR(20) AS $$
DECLARE
    v_direct_status VARCHAR(20);
    v_parent_status VARCHAR(20);
    v_effective_status VARCHAR(20);
BEGIN
    -- 엔티티의 직접 상태와 부모 상태 조회
    SELECT status, parent_status 
    INTO v_direct_status, v_parent_status
    FROM unified_entity_status 
    WHERE entity_type = p_entity_type AND entity_id = p_entity_id;
    
    -- 효과적 상태 계산 (계층적 영향)
    v_effective_status := CASE
        -- 부모가 terminated면 자식도 효과적으로 terminated
        WHEN v_parent_status = 'terminated' THEN 'terminated'
        -- 부모가 inactive면 자식도 효과적으로 inactive (단, 자식이 terminated가 아닌 경우)
        WHEN v_parent_status = 'inactive' AND v_direct_status != 'terminated' THEN 'inactive'
        -- 그 외에는 자신의 직접 상태
        ELSE v_direct_status
    END;
    
    RETURN v_effective_status;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===============================
-- 5. 엔터티 상태 변경 함수들 (실제 구현 버전)
-- ===============================

-- 5-1. 통일된 엔터티 상태 변경 함수
CREATE OR REPLACE FUNCTION set_entity_status(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER,
    p_new_status VARCHAR(20),
    p_changed_by INTEGER DEFAULT NULL,
    p_reason TEXT DEFAULT NULL
) RETURNS JSONB AS $$
DECLARE
    v_result JSONB := '{}';
    v_old_status VARCHAR(20);
    v_current_user_id INTEGER;
    v_has_permission BOOLEAN := FALSE;
    v_debug_info JSONB := '{}';
BEGIN
    -- 🔧 디버깅 정보 수집 시작
    v_debug_info := jsonb_build_object(
        'function_start', true,
        'p_entity_type', p_entity_type,
        'p_entity_id', p_entity_id,
        'p_new_status', p_new_status
    );

    -- 1. 입력값 검증: 유효한 상태값인지 확인
    IF NOT is_valid_status(p_new_status) THEN
        RETURN jsonb_build_object(
            'success', false, 
            'error', 'Invalid status. Must be: active, inactive, terminated',
            'debug', v_debug_info
        );
    END IF;
    
    -- 2. 현재 작업 수행 사용자 ID 설정
    v_current_user_id := COALESCE(p_changed_by, get_current_user_id());
    
    -- 🔧 디버깅 정보 업데이트
    v_debug_info := v_debug_info || jsonb_build_object(
        'current_user_id', v_current_user_id,
        'is_super_admin', is_super_admin(),
        'is_labor_office_member', is_labor_office_member(),
        'is_company_member', is_company_member()
    );
    
    -- 3. 엔터티 타입별 권한 검사 및 상태 변경
    CASE p_entity_type
        WHEN 'labor_office' THEN
            -- 노무사 사무실 상태 변경: SUPER_ADMIN만 가능 (최상위 엔터티)
            IF is_super_admin() THEN
                SELECT office_status INTO v_old_status 
                FROM labor_offices WHERE labor_office_id = p_entity_id;
                
                UPDATE labor_offices 
                SET office_status = p_new_status 
                WHERE labor_office_id = p_entity_id;
                
                v_has_permission := TRUE;
                v_debug_info := v_debug_info || jsonb_build_object('permission_type', 'super_admin_labor_office');
            END IF;
            
        WHEN 'company' THEN
            -- 회사 상태 변경: SUPER_ADMIN 또는 해당 회사에 접근 가능한 LABOR_ADMIN
            IF is_super_admin() THEN
                v_has_permission := TRUE;
                v_debug_info := v_debug_info || jsonb_build_object('permission_type', 'super_admin_company');
            ELSIF user_can_access_company(p_entity_id) AND user_has_role('LABOR_ADMIN') THEN
                v_has_permission := TRUE;
                v_debug_info := v_debug_info || jsonb_build_object('permission_type', 'labor_admin_company');
            END IF;
            
            IF v_has_permission THEN
                SELECT client_status INTO v_old_status 
                FROM companies WHERE company_id = p_entity_id;
                
                UPDATE companies 
                SET client_status = p_new_status 
                WHERE company_id = p_entity_id;
            END IF;
            
        WHEN 'worker' THEN
            -- 근로자 상태 변경: SUPER_ADMIN, LABOR_ADMIN/STAFF (담당 회사), COMPANY_ADMIN (자신 회사)
            IF is_super_admin() THEN
                v_has_permission := TRUE;
                v_debug_info := v_debug_info || jsonb_build_object('permission_type', 'super_admin_worker');
            ELSIF EXISTS (
                SELECT 1 FROM workers w 
                JOIN companies c ON w.company_id = c.company_id 
                WHERE w.worker_id = p_entity_id 
                  AND user_can_access_company(c.company_id)
                  AND (user_has_role('LABOR_ADMIN') OR user_has_role('LABOR_STAFF') OR user_has_role('COMPANY_ADMIN'))
            ) THEN
                v_has_permission := TRUE;
                v_debug_info := v_debug_info || jsonb_build_object('permission_type', 'company_access_worker');
            END IF;
            
            IF v_has_permission THEN
                SELECT employment_status INTO v_old_status 
                FROM workers WHERE worker_id = p_entity_id;
                
                UPDATE workers 
                SET employment_status = p_new_status 
                WHERE worker_id = p_entity_id;
                
                -- 근로자가 terminated되면 사용자 계정도 terminated
                IF p_new_status = 'terminated' THEN
                    UPDATE users 
                    SET user_status = 'terminated', is_active = false 
                    WHERE user_id = p_entity_id;
                END IF;
            END IF;
            
        WHEN 'labor_staff' THEN
            -- 노무사 사무실 직원 상태 변경: SUPER_ADMIN 또는 같은 노무사 사무실의 LABOR_ADMIN
            IF is_super_admin() THEN
                v_has_permission := TRUE;
                v_debug_info := v_debug_info || jsonb_build_object('permission_type', 'super_admin_labor_staff');
            ELSIF EXISTS (
                SELECT 1 FROM labor_office_staff los
                WHERE los.staff_id = p_entity_id 
                  AND los.labor_office_id = get_user_labor_office_id()
                  AND user_has_role('LABOR_ADMIN')
            ) THEN
                v_has_permission := TRUE;
                v_debug_info := v_debug_info || jsonb_build_object('permission_type', 'labor_admin_staff');
            END IF;
            
            IF v_has_permission THEN
                SELECT employment_status INTO v_old_status 
                FROM labor_office_staff WHERE staff_id = p_entity_id;
                
                UPDATE labor_office_staff 
                SET employment_status = p_new_status 
                WHERE staff_id = p_entity_id;
            END IF;
            
        WHEN 'user' THEN
            -- 사용자 계정 상태 변경: SUPER_ADMIN 또는 자신의 계정
            IF is_super_admin() THEN
                v_has_permission := TRUE;
                v_debug_info := v_debug_info || jsonb_build_object('permission_type', 'super_admin_user');
            ELSIF p_entity_id = v_current_user_id THEN
                v_has_permission := TRUE;
                v_debug_info := v_debug_info || jsonb_build_object('permission_type', 'self_user');
            END IF;
            
            IF v_has_permission THEN
                SELECT user_status INTO v_old_status 
                FROM users WHERE user_id = p_entity_id;
                
                UPDATE users 
                SET user_status = p_new_status, is_active = (p_new_status = 'active') 
                WHERE user_id = p_entity_id;
            END IF;
            
        ELSE
            RETURN jsonb_build_object(
                'success', false, 
                'error', 'Invalid entity type',
                'debug', v_debug_info
            );
    END CASE;
    
    -- 4. 권한이 없는 경우 에러 반환
    IF NOT v_has_permission THEN
        RETURN jsonb_build_object(
            'success', false, 
            'error', 'Permission denied',
            'debug', v_debug_info || jsonb_build_object(
                'user_labor_office_id', get_user_labor_office_id(),
                'user_company_id', get_user_company_id(),
                'can_access_company', CASE 
                    WHEN p_entity_type = 'company' THEN user_can_access_company(p_entity_id)
                    ELSE NULL 
                END
            )
        );
    END IF;
    
    -- 5. 성공 결과 반환
    v_result := jsonb_build_object(
        'success', true,
        'entity_type', p_entity_type,
        'entity_id', p_entity_id,
        'old_status', v_old_status,
        'new_status', p_new_status,
        'changed_by', v_current_user_id,
        'reason', p_reason,
        'changed_at', CURRENT_TIMESTAMP,
        'debug', v_debug_info
    );
    
    RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 5-2. 하위 엔티티 일괄 상태 변경 함수


-- 5-3. 스마트 상태 변경 함수 (실제 구현 버전)


-- ===============================
-- 6. 편의 액션 함수들 (실제 구현 버전)
-- ===============================

-- 6-1. 엔터티 활성화
CREATE OR REPLACE FUNCTION activate_entity(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER,
    p_reason TEXT DEFAULT NULL
) RETURNS JSONB AS $$
BEGIN
    RETURN smart_set_entity_status(p_entity_type, p_entity_id, 'active', TRUE, p_reason);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6-2. 엔터티 비활성화
CREATE OR REPLACE FUNCTION deactivate_entity(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER,
    p_reason TEXT DEFAULT NULL
) RETURNS JSONB AS $$
BEGIN
    RETURN smart_set_entity_status(p_entity_type, p_entity_id, 'inactive', TRUE, p_reason);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6-3. 엔터티 종료
CREATE OR REPLACE FUNCTION terminate_entity(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER,
    p_reason TEXT DEFAULT NULL
) RETURNS JSONB AS $$
BEGIN
    RETURN smart_set_entity_status(p_entity_type, p_entity_id, 'terminated', TRUE, p_reason);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===============================
-- 7. 사용자 엔터티 상태 확인 함수 (야해마트 문제 해결 버전)
-- ===============================

-- 7-1. 현재 사용자의 엔터티 상태 확인 함수
CREATE OR REPLACE FUNCTION get_user_entity_status()
RETURNS TABLE (
    entity_type TEXT,
    entity_status TEXT,
    entity_id INTEGER,
    entity_name TEXT,
    message TEXT,
    role_category TEXT,
    role_code TEXT,
    effective_status TEXT
) AS $$
DECLARE
    v_user_id INTEGER;
    v_user_info RECORD;
    v_role_info RECORD;
    v_labor_office_info RECORD;
    v_company_info RECORD;
    v_worker_info RECORD;
BEGIN
    -- 현재 사용자 ID 가져오기
    v_user_id := get_current_user_id();
    
    -- 디버깅용 로그
    RAISE NOTICE '🔍 get_user_entity_status: user_id = %', v_user_id;
    
    IF v_user_id IS NULL OR v_user_id = 0 THEN
        RETURN QUERY SELECT 
            'unknown'::TEXT, 
            'inactive'::TEXT, 
            NULL::INTEGER, 
            'No User Context'::TEXT, 
            '사용자 컨텍스트가 설정되지 않았습니다.'::TEXT,
            'unknown'::TEXT,
            'unknown'::TEXT,
            'inactive'::TEXT;
        RETURN;
    END IF;

    -- 사용자 기본 정보 조회 (RLS 우회)
    SELECT u.user_id, u.username, u.name, u.is_active, u.user_status
    INTO v_user_info
    FROM users u
    WHERE u.user_id = v_user_id;
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT 
            'unknown'::TEXT, 
            'inactive'::TEXT, 
            NULL::INTEGER, 
            'User Not Found'::TEXT, 
            '사용자를 찾을 수 없습니다.'::TEXT,
            'unknown'::TEXT,
            'unknown'::TEXT,
            'inactive'::TEXT;
        RETURN;
    END IF;

    -- 역할 정보 조회 (RLS 우회를 위해 직접 쿼리)
    SELECT r.role_code, r.role_name, r.role_category
    INTO v_role_info
    FROM user_roles ur
    JOIN roles r ON ur.role_id = r.role_id
    WHERE ur.user_id = v_user_id
      AND ur.is_active = true
      AND (ur.end_date IS NULL OR ur.end_date >= CURRENT_DATE)
    ORDER BY 
        CASE 
            WHEN r.role_code = 'SUPER_ADMIN' THEN 1
            WHEN r.role_code = 'LABOR_ADMIN' THEN 2
            WHEN r.role_code = 'COMPANY_ADMIN' THEN 3
            ELSE 4
        END
    LIMIT 1;
    
    -- 디버깅용 로그
    RAISE NOTICE '🔍 Role found: % (% - %)', v_role_info.role_code, v_role_info.role_name, v_role_info.role_category;
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT 
            'user'::TEXT, 
            COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END)::TEXT, 
            v_user_info.user_id, 
            v_user_info.name::TEXT, 
            '역할이 배정되지 않았습니다.'::TEXT,
            'none'::TEXT,
            'none'::TEXT,
            COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END)::TEXT;
        RETURN;
    END IF;

    -- SUPER_ADMIN인 경우
    IF v_role_info.role_code = 'SUPER_ADMIN' THEN
        RETURN QUERY SELECT 
            'system'::TEXT, 
            'active'::TEXT, 
            v_user_info.user_id, 
            'System Administrator'::TEXT, 
            '시스템 관리자 권한으로 모든 기능에 접근 가능합니다.'::TEXT,
            'system'::TEXT,
            'SUPER_ADMIN'::TEXT,
            'active'::TEXT;
        RETURN;
    END IF;

    -- 노무사 사무실 역할인 경우
    IF v_role_info.role_category = 'labor_office' THEN
        SELECT los.labor_office_id, los.position, los.employment_status, lo.office_name, lo.office_status
        INTO v_labor_office_info
        FROM labor_office_staff los
        JOIN labor_offices lo ON los.labor_office_id = lo.labor_office_id
        WHERE los.user_id = v_user_id
          AND los.employment_status = 'active';
        
        IF FOUND THEN
            DECLARE
                v_direct_status TEXT := COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END);
                v_parent_status TEXT := v_labor_office_info.office_status;
                v_effective_status TEXT := CASE 
                    WHEN v_parent_status = 'active' THEN v_direct_status 
                    ELSE v_parent_status 
                END;
                v_message TEXT := CASE 
                    WHEN v_effective_status = 'active' THEN '모든 기능을 이용하실 수 있습니다.'
                    WHEN v_parent_status != 'active' THEN '노무사 사무실이 비활성화 상태입니다.'
                    ELSE '계정이 비활성화 상태입니다.'
                END;
            BEGIN
                RETURN QUERY SELECT 
                    'labor_office'::TEXT, 
                    v_direct_status, 
                    v_labor_office_info.labor_office_id, 
                    v_labor_office_info.office_name::TEXT, 
                    v_message,
                    'labor_office'::TEXT,
                    v_role_info.role_code::TEXT,
                    v_effective_status;
                RETURN;
            END;
        END IF;
    END IF;

    -- 회사 역할인 경우
    IF v_role_info.role_category = 'company' THEN
        -- 회사 부서 배정 확인
        SELECT d.company_id, c.company_name, c.client_status, uda.assignment_type
        INTO v_company_info
        FROM user_department_assignments uda
        JOIN departments d ON uda.department_id = d.department_id
        JOIN companies c ON d.company_id = c.company_id
        WHERE uda.user_id = v_user_id
          AND uda.is_active = true
        LIMIT 1;
        
        -- 직접 회사 배정 확인
        IF NOT FOUND THEN
            SELECT uca.company_id, c.company_name, c.client_status, uca.assignment_type
            INTO v_company_info
            FROM user_company_assignments uca
            JOIN companies c ON uca.company_id = c.company_id
            WHERE uca.user_id = v_user_id
              AND uca.is_active = true
            LIMIT 1;
        END IF;
        
        IF FOUND THEN
            DECLARE
                v_direct_status TEXT := COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END);
                v_parent_status TEXT := v_company_info.client_status;
                v_effective_status TEXT := CASE 
                    WHEN v_parent_status = 'active' THEN v_direct_status 
                    ELSE v_parent_status 
                END;
                v_message TEXT := CASE 
                    WHEN v_effective_status = 'active' THEN '모든 기능을 이용하실 수 있습니다.'
                    WHEN v_parent_status != 'active' THEN '소속 회사가 비활성화 상태입니다.'
                    ELSE '계정이 비활성화 상태입니다.'
                END;
            BEGIN
                RETURN QUERY SELECT 
                    'company'::TEXT, 
                    v_direct_status, 
                    v_company_info.company_id, 
                    v_company_info.company_name::TEXT, 
                    v_message,
                    'company'::TEXT,
                    v_role_info.role_code::TEXT,
                    v_effective_status;
                RETURN;
            END;
        END IF;
    END IF;

    -- 기본 사용자 (소속 없음)
    RETURN QUERY SELECT 
        'user'::TEXT, 
        COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END)::TEXT, 
        v_user_info.user_id, 
        v_user_info.name::TEXT, 
        CASE 
            WHEN COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END) = 'active' THEN '기본 기능을 이용하실 수 있습니다.'
            ELSE '계정이 비활성화 상태입니다.'
        END::TEXT,
        v_role_info.role_category::TEXT,
        v_role_info.role_code::TEXT,
        COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END)::TEXT;
    
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===============================
-- 8. 상태 조회 및 분석 함수들
-- ===============================

-- 8-1. 전체 엔터티 상태 현황 조회
CREATE OR REPLACE FUNCTION get_entity_status_summary()
RETURNS TABLE (
    entity_type VARCHAR(20),
    active_count BIGINT,
    inactive_count BIGINT,
    terminated_count BIGINT,
    total_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ues.entity_type,
        COUNT(*) FILTER (WHERE ues.status = 'active') as active_count,
        COUNT(*) FILTER (WHERE ues.status = 'inactive') as inactive_count,
        COUNT(*) FILTER (WHERE ues.status = 'terminated') as terminated_count,
        COUNT(*) as total_count
    FROM unified_entity_status ues
    GROUP BY ues.entity_type
    ORDER BY ues.entity_type;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 8-2. 특정 엔터티 상세 상태 조회
CREATE OR REPLACE FUNCTION get_entity_detailed_status(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER
) RETURNS JSONB AS $$
DECLARE
    v_entity_info RECORD;
    v_children JSONB := '[]';
    v_result JSONB;
    rec RECORD;
BEGIN
    -- 기본 엔터티 정보 조회
    SELECT * INTO v_entity_info
    FROM unified_entity_status 
    WHERE entity_type = p_entity_type AND entity_id = p_entity_id;
    
    -- 하위 엔터티들 조회
    IF p_entity_type = 'labor_office' THEN
        -- 노무사 직원들과 담당 회사들
        FOR rec IN 
            SELECT entity_type, entity_id, entity_name, status
            FROM unified_entity_status 
            WHERE parent_entity_type = 'labor_office' 
              AND parent_entity_id = p_entity_id
        LOOP
            v_children := v_children || to_jsonb(rec);
        END LOOP;
        
    ELSIF p_entity_type = 'company' THEN
        -- 회사 근로자들
        FOR rec IN 
            SELECT entity_type, entity_id, entity_name, status
            FROM unified_entity_status 
            WHERE parent_entity_type = 'company' 
              AND parent_entity_id = p_entity_id
        LOOP
            v_children := v_children || to_jsonb(rec);
        END LOOP;
    END IF;
    
    -- 결과 구성
    v_result := to_jsonb(v_entity_info) || jsonb_build_object(
        'effective_status', get_effective_status(p_entity_type, p_entity_id),
        'children', v_children,
        'children_count', jsonb_array_length(v_children)
    );
    
    RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 8-3. 사용자 엔터티 활성 상태 확인
CREATE OR REPLACE FUNCTION is_user_entity_active()
RETURNS BOOLEAN AS $$
DECLARE
    user_status RECORD;
BEGIN
    SELECT * INTO user_status FROM get_user_entity_status() LIMIT 1;
    
    -- system 카테고리는 항상 활성
    IF user_status.role_category = 'system' THEN
        RETURN TRUE;
    END IF;
    
    -- 효과적 상태 기준으로 판단
    RETURN user_status.effective_status = 'active';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 8-4. 엔터티 접근 가능 여부 확인
CREATE OR REPLACE FUNCTION entity_is_accessible(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER
) RETURNS BOOLEAN AS $$
DECLARE
    v_effective_status VARCHAR(20);
BEGIN
    -- SUPER_ADMIN은 모든 상태의 엔터티 접근 가능
    IF is_super_admin() THEN
        RETURN TRUE;
    END IF;
    
    -- 일반 사용자는 terminated 엔터티 접근 불가
    v_effective_status := get_effective_status(p_entity_type, p_entity_id);
    
    RETURN v_effective_status != 'terminated';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 8-5. 활성 사용자 확인 함수 업데이트
CREATE OR REPLACE FUNCTION user_is_active()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM users 
        WHERE user_id = get_current_user_id() 
          AND (user_status = 'active' OR (user_status IS NULL AND is_active = TRUE))
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===============================
-- 9. 엔터티 상태 상세 정보 함수들
-- ===============================

-- 9-1. 엔터티 상태 상세 정보 조회
CREATE OR REPLACE FUNCTION get_entity_status_details()
RETURNS TABLE (
    entity_type TEXT,
    entity_status TEXT,
    entity_name TEXT,
    status_message TEXT,
    can_access BOOLEAN,
    restricted_features TEXT[],
    admin_contact TEXT,
    role_category TEXT,
    role_code TEXT,
    effective_status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ues.entity_type,
        ues.entity_status,
        ues.entity_name,
        ues.message as status_message,
        CASE 
            WHEN ues.role_category = 'system' THEN true
            ELSE (ues.effective_status = 'active')
        END as can_access,
        CASE 
            WHEN ues.role_category = 'system' THEN ARRAY[]::TEXT[]
            WHEN ues.effective_status = 'inactive' THEN 
                ARRAY['data_modification', 'report_generation', 'setting_changes']::TEXT[]
            WHEN ues.effective_status = 'terminated' THEN 
                ARRAY['data_modification', 'report_generation', 'setting_changes', 'data_view']::TEXT[]
            ELSE ARRAY[]::TEXT[]
        END as restricted_features,
        CASE 
            WHEN ues.entity_type = 'labor_office' THEN '노무사 사무실 관리자에게 문의하세요.'::TEXT
            WHEN ues.entity_type = 'company' THEN '회사 관리자에게 문의하세요.'::TEXT
            WHEN ues.entity_type = 'worker' THEN '회사 인사담당자에게 문의하세요.'::TEXT
            WHEN ues.entity_type = 'system' THEN '시스템이 정상 작동 중입니다.'::TEXT
            ELSE '시스템 관리자에게 문의하세요.'::TEXT
        END as admin_contact,
        ues.role_category,
        ues.role_code,
        ues.effective_status
    FROM get_user_entity_status() ues;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===============================
-- 10. 성능 최적화 인덱스
-- ===============================

-- 상태 기반 조회 최적화
CREATE INDEX IF NOT EXISTS idx_labor_offices_status ON labor_offices(office_status);
CREATE INDEX IF NOT EXISTS idx_companies_status ON companies(client_status);
CREATE INDEX IF NOT EXISTS idx_workers_status ON workers(employment_status);
CREATE INDEX IF NOT EXISTS idx_labor_staff_status ON labor_office_staff(employment_status);
CREATE INDEX IF NOT EXISTS idx_users_status ON users(user_status);
CREATE INDEX IF NOT EXISTS idx_users_is_active ON users(is_active);

-- 계층 관계 조회 최적화
CREATE INDEX IF NOT EXISTS idx_companies_labor_office ON companies(labor_office_id, client_status);
CREATE INDEX IF NOT EXISTS idx_workers_company ON workers(company_id, employment_status);
CREATE INDEX IF NOT EXISTS idx_labor_staff_office ON labor_office_staff(labor_office_id, employment_status);

-- RLS 함수 최적화
CREATE INDEX IF NOT EXISTS idx_user_roles_user_active ON user_roles(user_id, is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_user_company_assignments_active ON user_company_assignments(user_id, company_id, is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_user_department_assignments_active ON user_department_assignments(user_id, is_active) WHERE is_active = true;

-- ===============================
-- 11. 함수 설명 및 주석
-- ===============================

COMMENT ON FUNCTION get_current_user_id() IS '현재 로그인한 사용자 ID 조회 (세션 변수 기반, RLS 핵심)';
COMMENT ON FUNCTION set_current_user_context(INTEGER) IS '사용자 로그인 시 컨텍스트 설정 (애플리케이션에서 호출)';
COMMENT ON FUNCTION user_has_role(TEXT) IS '현재 사용자가 특정 역할을 가지고 있는지 확인 (RLS 핵심)';
COMMENT ON FUNCTION is_super_admin() IS 'SUPER_ADMIN 권한 확인 (모든 데이터 접근 가능)';
COMMENT ON FUNCTION user_can_access_company(INTEGER) IS '현재 사용자가 특정 회사에 접근 가능한지 확인 (RLS 핵심)';
COMMENT ON FUNCTION set_entity_status(VARCHAR, INTEGER, VARCHAR, INTEGER, TEXT) IS '통일된 엔터티 상태 변경 함수 (active, inactive, terminated)';
COMMENT ON FUNCTION get_effective_status(VARCHAR, INTEGER) IS '계층적 관계를 고려한 실제 유효 상태 계산';
COMMENT ON FUNCTION smart_set_entity_status(VARCHAR, INTEGER, VARCHAR, BOOLEAN, TEXT) IS '하위 엔터티 자동 처리를 포함한 스마트 상태 변경';
COMMENT ON FUNCTION get_user_entity_status() IS '현재 사용자의 소속 엔터티 상태 확인 (야해마트 문제 해결 포함)';
COMMENT ON FUNCTION activate_entity(VARCHAR, INTEGER, TEXT) IS '엔터티 활성화 편의 함수';
COMMENT ON FUNCTION deactivate_entity(VARCHAR, INTEGER, TEXT) IS '엔터티 비활성화 편의 함수';
COMMENT ON FUNCTION terminate_entity(VARCHAR, INTEGER, TEXT) IS '엔터티 종료 편의 함수';
COMMENT ON VIEW unified_entity_status IS '모든 엔터티의 통일된 상태 조회 뷰 (계층 관계 포함)';

-- ===============================
-- 12. 일용직 4대보험 시스템 (paste.txt 기반 추가)
-- ===============================

-- 12-1. 일용직 연속 근무 기간 자동 업데이트 함수
CREATE OR REPLACE FUNCTION update_daily_worker_continuous_periods(
    p_worker_id INTEGER,
    p_work_date DATE DEFAULT CURRENT_DATE
) RETURNS VOID AS $
DECLARE
    v_last_work_date DATE;
    v_current_period RECORD;
    v_employment_type VARCHAR(20);
    v_gap_days INTEGER;
BEGIN
    -- 고용형태 확인 (일용직만 처리)
    SELECT et.type_code INTO v_employment_type
    FROM workers w
    JOIN employment_types et ON w.employment_type_id = et.employment_type_id
    WHERE w.worker_id = p_worker_id;
    
    IF v_employment_type != 'DAILY' THEN
        RETURN;
    END IF;
    
    -- 현재 활성 연속 근무 기간 조회
    SELECT * INTO v_current_period
    FROM daily_worker_continuous_periods
    WHERE worker_id = p_worker_id AND is_active = TRUE
    ORDER BY continuous_start_date DESC
    LIMIT 1;
    
    -- 마지막 근무일 조회
    SELECT MAX(work_date) INTO v_last_work_date
    FROM attendance_records
    WHERE worker_id = p_worker_id 
      AND work_date <= p_work_date
      AND attendance_status = 'present';
    
    IF v_current_period IS NULL THEN
        -- 새로운 연속 근무 기간 시작
        IF v_last_work_date IS NOT NULL THEN
            INSERT INTO daily_worker_continuous_periods (
                worker_id, continuous_start_date, is_active, 
                total_work_days, total_work_hours, total_work_income
            ) VALUES (
                p_worker_id, v_last_work_date, TRUE,
                1, 
                (SELECT COALESCE(total_hours, 0) FROM attendance_records WHERE worker_id = p_worker_id AND work_date = v_last_work_date),
                (SELECT COALESCE(total_daily_pay, 0) FROM attendance_records WHERE worker_id = p_worker_id AND work_date = v_last_work_date)
            );
        END IF;
    ELSE
        -- 기존 연속 근무 기간 업데이트
        v_gap_days := p_work_date - v_current_period.continuous_start_date;
        
        IF v_gap_days > 30 THEN
            -- 30일 초과 간격이면 기존 기간 종료하고 새 기간 시작
            UPDATE daily_worker_continuous_periods 
            SET is_active = FALSE, continuous_end_date = v_current_period.continuous_start_date + INTERVAL '30 days'
            WHERE period_id = v_current_period.period_id;
            
            -- 새로운 연속 근무 기간 시작
            INSERT INTO daily_worker_continuous_periods (
                worker_id, continuous_start_date, is_active,
                total_work_days, total_work_hours, total_work_income
            ) VALUES (
                p_worker_id, p_work_date, TRUE,
                1,
                (SELECT COALESCE(total_hours, 0) FROM attendance_records WHERE worker_id = p_worker_id AND work_date = p_work_date),
                (SELECT COALESCE(total_daily_pay, 0) FROM attendance_records WHERE worker_id = p_worker_id AND work_date = p_work_date)
            );
        ELSE
            -- 기존 연속 근무 기간 연장
            UPDATE daily_worker_continuous_periods 
            SET 
                total_work_days = (
                    SELECT COUNT(*) 
                    FROM attendance_records 
                    WHERE worker_id = p_worker_id 
                      AND work_date BETWEEN v_current_period.continuous_start_date AND p_work_date
                      AND attendance_status = 'present'
                ),
                total_work_hours = (
                    SELECT COALESCE(SUM(total_hours), 0)
                    FROM attendance_records 
                    WHERE worker_id = p_worker_id 
                      AND work_date BETWEEN v_current_period.continuous_start_date AND p_work_date
                      AND attendance_status = 'present'
                ),
                total_work_income = (
                    SELECT COALESCE(SUM(total_daily_pay), 0)
                    FROM attendance_records 
                    WHERE worker_id = p_worker_id 
                      AND work_date BETWEEN v_current_period.continuous_start_date AND p_work_date
                      AND attendance_status = 'present'
                ),
                last_calculation_date = p_work_date,
                updated_at = CURRENT_TIMESTAMP
            WHERE period_id = v_current_period.period_id;
        END IF;
    END IF;
END;
$ LANGUAGE plpgsql;

-- 12-2. 롤링 월별 4대보험 자격 판정 함수
CREATE OR REPLACE FUNCTION process_rolling_monthly_insurance_eligibility(
    p_worker_id INTEGER,
    p_evaluation_date DATE DEFAULT CURRENT_DATE
) RETURNS VOID AS $
DECLARE
    v_worker_details RECORD;
    v_current_status RECORD;
    v_employment_criteria RECORD;
    v_rolling_period_start DATE;
    v_rolling_period_end DATE;
    v_attendance_summary RECORD;
    v_total_income NUMERIC(12,2) := 0;
    v_np_eligible BOOLEAN := FALSE;
    v_hi_eligible BOOLEAN := FALSE;
    v_ei_eligible BOOLEAN := FALSE;
    v_wc_eligible BOOLEAN := TRUE;
    v_np_reason TEXT;
    v_hi_reason TEXT;
    v_ei_reason TEXT;
    v_wc_reason TEXT;
    v_np_action VARCHAR(20) := 'none';
    v_hi_action VARCHAR(20) := 'none';
    v_ei_action VARCHAR(20) := 'none';
    v_wc_action VARCHAR(20) := 'none';
BEGIN
    -- 1. 근로자 정보 및 현재 4대보험 가입 상태 조회
    SELECT w.*, et.type_code, et.judgment_method, et.np_criteria, et.hi_criteria, et.ei_criteria, et.wc_criteria
    INTO v_worker_details
    FROM workers w
    JOIN employment_types et ON w.employment_type_id = et.employment_type_id
    WHERE w.worker_id = p_worker_id;
    
    -- 롤링 월별 판정이 아닌 경우 처리 중단
    IF v_worker_details.judgment_method != 'rolling_monthly' THEN
        RETURN;
    END IF;
    
    -- 현재 보험 가입 상태 조회
    SELECT * INTO v_current_status
    FROM current_insurance_status
    WHERE worker_id = p_worker_id;
    
    IF v_current_status IS NULL THEN
        -- 현재 가입 상태 레코드가 없으면 생성
        INSERT INTO current_insurance_status (worker_id) VALUES (p_worker_id);
        SELECT * INTO v_current_status FROM current_insurance_status WHERE worker_id = p_worker_id;
    END IF;
    
    -- 2. 순환 판정 기간 설정 (evaluation_date 기준 역산 1개월)
    v_rolling_period_end := p_evaluation_date;
    v_rolling_period_start := p_evaluation_date - INTERVAL '1 month';
    
    -- 3. 순환 기간 내 근무 기록 집계
    SELECT 
        COUNT(*) as total_days_worked,
        COALESCE(SUM(total_hours), 0) as total_hours_worked
    INTO v_attendance_summary
    FROM attendance_records
    WHERE worker_id = p_worker_id
      AND work_date BETWEEN v_rolling_period_start AND v_rolling_period_end
      AND attendance_status = 'present';
    
    -- 총 소득 계산
    SELECT COALESCE(SUM(total_daily_pay), 0) INTO v_total_income
    FROM attendance_records
    WHERE worker_id = p_worker_id
      AND work_date BETWEEN v_rolling_period_start AND v_rolling_period_end
      AND attendance_status = 'present';
    
    -- 4. 각 보험별 자격 판정
    
    -- 산재보험 (WC): 1일 이상 근무
    IF v_attendance_summary.total_days_worked >= 1 THEN
        v_wc_eligible := TRUE;
        v_wc_reason := '1일 이상 근무';
    ELSE
        v_wc_eligible := FALSE;
        v_wc_reason := '근무일수 미달';
    END IF;
    
    -- 고용보험 (EI): 1일 이상 근무
    IF v_attendance_summary.total_days_worked >= 1 THEN
        v_ei_eligible := TRUE;
        v_ei_reason := '1일 이상 근무';
    ELSE
        v_ei_eligible := FALSE;
        v_ei_reason := '근무일수 미달';
    END IF;
    
    -- 국민연금 (NP): 1개월간 8일 이상 or 60시간 이상 근무 or 월 220만원 이상
    IF v_attendance_summary.total_days_worked >= 8 OR 
       v_attendance_summary.total_hours_worked >= 60 OR 
       v_total_income >= 2200000 THEN
        v_np_eligible := TRUE;
        v_np_reason := '1개월간 8일 이상 또는 60시간 이상 근무 기준 충족';
    ELSE
        v_np_eligible := FALSE;
        v_np_reason := '가입 기준 미충족';
    END IF;
    
    -- 건강보험 (HI): 1개월간 8일 이상 or 60시간 이상 근무
    IF v_attendance_summary.total_days_worked >= 8 OR 
       v_attendance_summary.total_hours_worked >= 60 THEN
        v_hi_eligible := TRUE;
        v_hi_reason := '1개월간 8일 이상 또는 60시간 이상 근무 기준 충족';
    ELSE
        v_hi_eligible := FALSE;
        v_hi_reason := '가입 기준 미충족';
    END IF;
    
    -- 5. 이전 판정 결과와 비교하여 'action_required' 결정
    IF v_np_eligible AND NOT COALESCE(v_current_status.np_subscribed, FALSE) THEN
        v_np_action := 'acquire';
    ELSIF NOT v_np_eligible AND COALESCE(v_current_status.np_subscribed, FALSE) THEN
        v_np_action := 'lose';
    ELSE
        v_np_action := 'none';
    END IF;
    
    IF v_hi_eligible AND NOT COALESCE(v_current_status.hi_subscribed, FALSE) THEN
        v_hi_action := 'acquire';
    ELSIF NOT v_hi_eligible AND COALESCE(v_current_status.hi_subscribed, FALSE) THEN
        v_hi_action := 'lose';
    ELSE
        v_hi_action := 'none';
    END IF;
    
    IF v_ei_eligible AND NOT COALESCE(v_current_status.ei_subscribed, FALSE) THEN
        v_ei_action := 'acquire';
    ELSIF NOT v_ei_eligible AND COALESCE(v_current_status.ei_subscribed, FALSE) THEN
        v_ei_action := 'lose';
    ELSE
        v_ei_action := 'none';
    END IF;
    
    IF v_wc_eligible AND NOT COALESCE(v_current_status.wc_subscribed, FALSE) THEN
        v_wc_action := 'acquire';
    ELSIF NOT v_wc_eligible AND COALESCE(v_current_status.wc_subscribed, FALSE) THEN
        v_wc_action := 'lose';
    ELSE
        v_wc_action := 'none';
    END IF;
    
    -- 6. insurance_eligibility_records 테이블 업데이트 (또는 새로 생성)
    INSERT INTO insurance_eligibility_records (
        worker_id, judgment_type, rolling_period_start, rolling_period_end,
        work_days, work_hours, monthly_income,
        np_eligible, hi_eligible, ei_eligible, wc_eligible,
        np_reason, hi_reason, ei_reason, wc_reason,
        np_current_status, hi_current_status, ei_current_status, wc_current_status,
        np_action_required, hi_action_required, ei_action_required, wc_action_required,
        processing_status
    ) VALUES (
        p_worker_id, 'rolling_monthly', v_rolling_period_start, v_rolling_period_end,
        v_attendance_summary.total_days_worked, v_attendance_summary.total_hours_worked, v_total_income,
        v_np_eligible, v_hi_eligible, v_ei_eligible, v_wc_eligible,
        v_np_reason, v_hi_reason, v_ei_reason, v_wc_reason,
        COALESCE(v_current_status.np_subscribed, FALSE),
        COALESCE(v_current_status.hi_subscribed, FALSE),
        COALESCE(v_current_status.ei_subscribed, FALSE),
        COALESCE(v_current_status.wc_subscribed, FALSE),
        v_np_action, v_hi_action, v_ei_action, v_wc_action,
        'pending'
    ) ON CONFLICT (worker_id, rolling_period_start, judgment_type) DO UPDATE SET
        work_days = EXCLUDED.work_days,
        work_hours = EXCLUDED.work_hours,
        monthly_income = EXCLUDED.monthly_income,
        np_eligible = EXCLUDED.np_eligible,
        hi_eligible = EXCLUDED.hi_eligible,
        ei_eligible = EXCLUDED.ei_eligible,
        wc_eligible = EXCLUDED.wc_eligible,
        np_reason = EXCLUDED.np_reason,
        hi_reason = EXCLUDED.hi_reason,
        ei_reason = EXCLUDED.ei_reason,
        wc_reason = EXCLUDED.wc_reason,
        np_current_status = EXCLUDED.np_current_status,
        hi_current_status = EXCLUDED.hi_current_status,
        ei_current_status = EXCLUDED.ei_current_status,
        wc_current_status = EXCLUDED.wc_current_status,
        np_action_required = EXCLUDED.np_action_required,
        hi_action_required = EXCLUDED.hi_action_required,
        ei_action_required = EXCLUDED.ei_action_required,
        wc_action_required = EXCLUDED.wc_action_required,
        updated_at = CURRENT_TIMESTAMP;
        
    -- 7. 다음 판정일 설정 (current_insurance_status 업데이트)
    UPDATE current_insurance_status 
    SET next_judgment_date = p_evaluation_date + INTERVAL '1 day',
        last_updated = CURRENT_TIMESTAMP
    WHERE worker_id = p_worker_id;
    
END;
$ LANGUAGE plpgsql;

-- 12-3. 일일 배치 처리 함수
CREATE OR REPLACE FUNCTION run_daily_rolling_monthly_batch(
    p_batch_date DATE DEFAULT CURRENT_DATE - INTERVAL '1 day'
) RETURNS INTEGER AS $
DECLARE
    v_batch_log_id INTEGER;
    v_worker_id INTEGER;
    v_processed_count INTEGER := 0;
    v_success_count INTEGER := 0;
    v_error_count INTEGER := 0;
    v_error_messages TEXT[] := '{}';
BEGIN
    -- 배치 로그 시작
    INSERT INTO batch_processing_logs (
        batch_type, batch_date, processing_status, processing_notes
    ) VALUES (
        'daily_rolling_monthly', p_batch_date, 'running', 
        '일용직 롤링 월별 4대보험 자격 판정 배치 시작'
    ) RETURNING log_id INTO v_batch_log_id;
    
    -- 현재 활성 상태이며 'rolling_monthly' 판정 방식인 일용근로자 목록 조회
    FOR v_worker_id IN 
        SELECT DISTINCT w.worker_id
        FROM workers w
        JOIN employment_types et ON w.employment_type_id = et.employment_type_id
        WHERE et.judgment_method = 'rolling_monthly'
          AND w.employment_status = 'active'
          AND EXISTS (
              SELECT 1 FROM daily_worker_continuous_periods dwcp
              WHERE dwcp.worker_id = w.worker_id 
                AND dwcp.is_active = TRUE
                AND dwcp.continuous_start_date <= p_batch_date
          )
    LOOP
        BEGIN
            -- 각 일용근로자에 대해 자격 판정 함수 호출
            PERFORM process_rolling_monthly_insurance_eligibility(v_worker_id, p_batch_date);
            
            v_processed_count := v_processed_count + 1;
            v_success_count := v_success_count + 1;
            
        EXCEPTION WHEN OTHERS THEN
            v_processed_count := v_processed_count + 1;
            v_error_count := v_error_count + 1;
            v_error_messages := array_append(v_error_messages, 
                'Worker ID ' || v_worker_id || ': ' || SQLERRM);
        END;
    END LOOP;
    
    -- 배치 로그 완료
    UPDATE batch_processing_logs 
    SET 
        execution_end_time = CURRENT_TIMESTAMP,
        total_workers_processed = v_processed_count,
        successful_processes = v_success_count,
        failed_processes = v_error_count,
        processing_status = CASE WHEN v_error_count = 0 THEN 'completed' ELSE 'partial' END,
        error_messages = CASE WHEN v_error_count > 0 THEN v_error_messages ELSE NULL END,
        processing_notes = '총 ' || v_processed_count || '명 처리완료 (성공: ' || v_success_count || ', 실패: ' || v_error_count || ')'
    WHERE log_id = v_batch_log_id;
    
    -- 신고가 필요한 레코드들을 모아 실제 신고 처리 프로세스 트리거
    PERFORM process_pending_insurance_actions();
    
    RETURN v_processed_count;
END;
$ LANGUAGE plpgsql;

-- 12-4. 대기중인 4대보험 액션 처리 함수
CREATE OR REPLACE FUNCTION process_pending_insurance_actions() RETURNS INTEGER AS $
DECLARE
    v_pending_record RECORD;
    v_processed_count INTEGER := 0;
BEGIN
    -- 처리가 필요한 판정 결과 조회
    FOR v_pending_record IN
        SELECT 
            ier.worker_id,
            ier.np_action_required,
            ier.hi_action_required, 
            ier.ei_action_required,
            ier.wc_action_required,
            ier.rolling_period_end as effective_date,
            w.company_id
        FROM insurance_eligibility_records ier
        JOIN workers w ON ier.worker_id = w.worker_id
        WHERE ier.processing_status = 'pending'
          AND (ier.np_action_required IN ('acquire', 'lose') OR
               ier.hi_action_required IN ('acquire', 'lose') OR
               ier.ei_action_required IN ('acquire', 'lose') OR
               ier.wc_action_required IN ('acquire', 'lose'))
    LOOP
        -- 국민연금 처리
        IF v_pending_record.np_action_required IN ('acquire', 'lose') THEN
            INSERT INTO insurance_acquisitions_losses (
                worker_id, company_id, insurance_type, transaction_type,
                effective_date, reason_code, reason_description, auto_generated
            ) VALUES (
                v_pending_record.worker_id, v_pending_record.company_id, 'NP', 
                v_pending_record.np_action_required::TEXT,
                v_pending_record.effective_date, '10', 
                CASE WHEN v_pending_record.np_action_required = 'acquire' THEN '일용직 자격 충족' ELSE '일용직 자격 상실' END,
                TRUE
            );
        END IF;
        
        -- 건강보험, 고용보험, 산재보험 처리 (동일한 방식)
        IF v_pending_record.hi_action_required IN ('acquire', 'lose') THEN
            INSERT INTO insurance_acquisitions_losses (
                worker_id, company_id, insurance_type, transaction_type,
                effective_date, reason_code, reason_description, auto_generated
            ) VALUES (
                v_pending_record.worker_id, v_pending_record.company_id, 'HI', 
                v_pending_record.hi_action_required::TEXT,
                v_pending_record.effective_date, '10', 
                CASE WHEN v_pending_record.hi_action_required = 'acquire' THEN '일용직 자격 충족' ELSE '일용직 자격 상실' END,
                TRUE
            );
        END IF;
        
        IF v_pending_record.ei_action_required IN ('acquire', 'lose') THEN
            INSERT INTO insurance_acquisitions_losses (
                worker_id, company_id, insurance_type, transaction_type,
                effective_date, reason_code, reason_description, auto_generated
            ) VALUES (
                v_pending_record.worker_id, v_pending_record.company_id, 'EI', 
                v_pending_record.ei_action_required::TEXT,
                v_pending_record.effective_date, '10', 
                CASE WHEN v_pending_record.ei_action_required = 'acquire' THEN '일용직 자격 충족' ELSE '일용직 자격 상실' END,
                TRUE
            );
        END IF;
        
        IF v_pending_record.wc_action_required IN ('acquire', 'lose') THEN
            INSERT INTO insurance_acquisitions_losses (
                worker_id, company_id, insurance_type, transaction_type,
                effective_date, reason_code, reason_description, auto_generated
            ) VALUES (
                v_pending_record.worker_id, v_pending_record.company_id, 'WC', 
                v_pending_record.wc_action_required::TEXT,
                v_pending_record.effective_date, '10', 
                CASE WHEN v_pending_record.wc_action_required = 'acquire' THEN '일용직 자격 충족' ELSE '일용직 자격 상실' END,
                TRUE
            );
        END IF;
        
        -- 처리 상태 업데이트
        UPDATE insurance_eligibility_records 
        SET processing_status = 'processed'
        WHERE worker_id = v_pending_record.worker_id 
          AND processing_status = 'pending';
          
        v_processed_count := v_processed_count + 1;
    END LOOP;
    
    RETURN v_processed_count;
END;
$ LANGUAGE plpgsql;

-- 12-5. 근태 기록 트리거 (이벤트 기반)
CREATE OR REPLACE FUNCTION trigger_attendance_insurance_check()
RETURNS TRIGGER AS $
DECLARE
    v_judgment_method VARCHAR(20);
BEGIN
    -- 일용직인 경우에만 처리
    SELECT et.judgment_method INTO v_judgment_method
    FROM workers w
    JOIN employment_types et ON w.employment_type_id = et.employment_type_id
    WHERE w.worker_id = NEW.worker_id;
    
    IF v_judgment_method = 'rolling_monthly' THEN
        -- 연속 근무 기간 업데이트
        PERFORM update_daily_worker_continuous_periods(NEW.worker_id, NEW.work_date);
        
        -- 4대보험 자격 재판정 (즉시 또는 큐에 넣기)
        PERFORM process_rolling_monthly_insurance_eligibility(NEW.worker_id, NEW.work_date);
    END IF;
    
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

-- 트리거 생성
DROP TRIGGER IF EXISTS auto_insurance_check_on_attendance ON attendance_records;
CREATE TRIGGER auto_insurance_check_on_attendance
    AFTER INSERT OR UPDATE ON attendance_records
    FOR EACH ROW EXECUTE FUNCTION trigger_attendance_insurance_check();

-- ===============================
-- 13. 이메일 인증 시스템 (paste.txt 기반 추가)
-- ===============================

-- 13-1. 사용자 테이블에 이메일 인증 컬럼 추가
ALTER TABLE users ADD COLUMN IF NOT EXISTS email_verification_token VARCHAR(255);
ALTER TABLE users ADD COLUMN IF NOT EXISTS email_verification_expires_at TIMESTAMP WITH TIME ZONE;
ALTER TABLE users ADD COLUMN IF NOT EXISTS verification_sent_at TIMESTAMP WITH TIME ZONE;
ALTER TABLE users ADD COLUMN IF NOT EXISTS verification_attempts INTEGER DEFAULT 0;

-- 13-2. 이메일 인증 로그 테이블 생성
CREATE TABLE IF NOT EXISTS email_verification_logs (
    log_id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    verification_type VARCHAR(20) NOT NULL CHECK (verification_type IN ('registration', 'resend', 'manual')),
    email_address VARCHAR(100) NOT NULL,
    token_hash VARCHAR(255) NOT NULL,
    sent_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    ip_address INET,
    user_agent TEXT,
    status VARCHAR(20) DEFAULT 'sent' CHECK (status IN ('sent', 'verified', 'expired', 'failed'))
);

-- 13-3. 이메일 인증 관련 인덱스
CREATE INDEX IF NOT EXISTS idx_users_email_verification_token ON users(email_verification_token);
CREATE INDEX IF NOT EXISTS idx_users_email_verified ON users(is_email_verified);
CREATE INDEX IF NOT EXISTS idx_email_verification_logs_user_id ON email_verification_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_email_verification_logs_token_hash ON email_verification_logs(token_hash);

-- 13-4. 이메일 인증 관련 함수들
CREATE OR REPLACE FUNCTION generate_verification_token()
RETURNS VARCHAR(255) AS $
BEGIN
    RETURN encode(gen_random_bytes(32), 'hex');
END;
$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION is_verification_token_valid(
    p_user_id INTEGER,
    p_token VARCHAR(255)
)
RETURNS BOOLEAN AS $
DECLARE
    token_exists BOOLEAN := FALSE;
BEGIN
    SELECT EXISTS(
        SELECT 1 FROM users 
        WHERE user_id = p_user_id 
          AND email_verification_token = p_token
          AND email_verification_expires_at > CURRENT_TIMESTAMP
          AND is_email_verified = FALSE
    ) INTO token_exists;
    
    RETURN token_exists;
END;
$ LANGUAGE plpgsql;

-- 13-5. 이메일 인증 완료 함수
CREATE OR REPLACE FUNCTION complete_email_verification(
    p_user_id INTEGER,
    p_token VARCHAR(255)
)
RETURNS BOOLEAN AS $
DECLARE
    verification_completed BOOLEAN := FALSE;
BEGIN
    -- 토큰 유효성 검사 후 인증 완료
    UPDATE users 
    SET 
        is_email_verified = TRUE,
        email_verification_token = NULL,
        email_verification_expires_at = NULL,
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = p_user_id 
      AND email_verification_token = p_token
      AND email_verification_expires_at > CURRENT_TIMESTAMP
      AND is_email_verified = FALSE;
    
    GET DIAGNOSTICS verification_completed = ROW_COUNT;
    
    IF verification_completed THEN
        -- 로그 업데이트
        UPDATE email_verification_logs 
        SET 
            status = 'verified',
            verified_at = CURRENT_TIMESTAMP
        WHERE user_id = p_user_id 
          AND token_hash = encode(sha256(p_token::bytea), 'hex')
          AND status = 'sent';
    END IF;
    
    RETURN verification_completed > 0;
END;
$ LANGUAGE plpgsql;

-- 13-6. 이메일 인증 토큰 생성 및 로그 기록 함수
CREATE OR REPLACE FUNCTION create_verification_token(
    p_user_id INTEGER,
    p_verification_type VARCHAR(20) DEFAULT 'registration',
    p_ip_address INET DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL
)
RETURNS VARCHAR(255) AS $
DECLARE
    new_token VARCHAR(255);
    user_email VARCHAR(100);
BEGIN
    -- 새 토큰 생성
    new_token := generate_verification_token();
    
    -- 사용자 이메일 조회
    SELECT email INTO user_email FROM users WHERE user_id = p_user_id;
    
    -- 사용자 테이블 업데이트
    UPDATE users 
    SET 
        email_verification_token = new_token,
        email_verification_expires_at = CURRENT_TIMESTAMP + INTERVAL '24 hours',
        verification_sent_at = CURRENT_TIMESTAMP,
        verification_attempts = verification_attempts + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = p_user_id;
    
    -- 로그 기록
    INSERT INTO email_verification_logs (
        user_id, 
        verification_type, 
        email_address, 
        token_hash, 
        expires_at,
        ip_address,
        user_agent
    ) VALUES (
        p_user_id,
        p_verification_type,
        user_email,
        encode(sha256(new_token::bytea), 'hex'),
        CURRENT_TIMESTAMP + INTERVAL '24 hours',
        p_ip_address,
        p_user_agent
    );
    
    RETURN new_token;
END;
$ LANGUAGE plpgsql;

-- 13-7. 만료된 토큰 정리 함수 (배치용)
CREATE OR REPLACE FUNCTION cleanup_expired_verification_tokens()
RETURNS INTEGER AS $
DECLARE
    cleaned_count INTEGER;
BEGIN
    -- 만료된 토큰 정리
    UPDATE users 
    SET 
        email_verification_token = NULL,
        email_verification_expires_at = NULL
    WHERE email_verification_expires_at < CURRENT_TIMESTAMP;
    
    GET DIAGNOSTICS cleaned_count = ROW_COUNT;
    
    -- 만료된 로그 상태 업데이트
    UPDATE email_verification_logs 
    SET status = 'expired'
    WHERE expires_at < CURRENT_TIMESTAMP 
      AND status = 'sent';
    
    RETURN cleaned_count;
END;
$ LANGUAGE plpgsql;

-- 13-8. 로그인 횟수 증가 함수
CREATE OR REPLACE FUNCTION increment_login_count(user_id_param INTEGER)
RETURNS VOID AS $
BEGIN
    UPDATE users
    SET login_count = COALESCE(login_count, 0) + 1,
        last_login = CURRENT_TIMESTAMP
    WHERE user_id = user_id_param;
END;
$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===============================
-- 14. 주요 뷰들 (paste.txt 기반 추가)
-- ===============================

-- 14-1. 일용직 4대보험 판정 현황 뷰
CREATE OR REPLACE VIEW v_daily_worker_insurance_status AS
SELECT 
    w.worker_id,
    w.name as worker_name,
    w.employee_number,
    c.company_name,
    d.department_name,
    dwcp.continuous_start_date,
    dwcp.total_work_days,
    dwcp.total_work_hours,
    dwcp.total_work_income,
    
    cis.np_subscribed,
    cis.hi_subscribed,
    cis.ei_subscribed,
    cis.wc_subscribed,
    cis.next_judgment_date,
    
    ier.np_eligible as latest_np_eligible,
    ier.hi_eligible as latest_hi_eligible,
    ier.ei_eligible as latest_ei_eligible,
    ier.wc_eligible as latest_wc_eligible,
    
    ier.np_action_required,
    ier.hi_action_required,
    ier.ei_action_required,
    ier.wc_action_required,
    
    ier.processing_status,
    ier.rolling_period_start as last_judgment_period_start,
    ier.rolling_period_end as last_judgment_period_end
    
FROM workers w
JOIN companies c ON w.company_id = c.company_id
JOIN employment_types et ON w.employment_type_id = et.employment_type_id
LEFT JOIN departments d ON w.department_id = d.department_id
LEFT JOIN daily_worker_continuous_periods dwcp ON w.worker_id = dwcp.worker_id AND dwcp.is_active = TRUE
LEFT JOIN current_insurance_status cis ON w.worker_id = cis.worker_id
LEFT JOIN LATERAL (
    SELECT * FROM insurance_eligibility_records 
    WHERE worker_id = w.worker_id AND judgment_type = 'rolling_monthly'
    ORDER BY rolling_period_end DESC LIMIT 1
) ier ON true
WHERE et.judgment_method = 'rolling_monthly'
  AND w.employment_status = 'active';

-- 14-2. 배치 처리 모니터링 뷰
CREATE OR REPLACE VIEW v_batch_processing_monitor AS
SELECT 
    bpl.log_id,
    bpl.batch_type,
    bpl.batch_date,
    bpl.execution_start_time,
    bpl.execution_end_time,
    EXTRACT(EPOCH FROM (bpl.execution_end_time - bpl.execution_start_time)) / 60 as execution_minutes,
    bpl.total_workers_processed,
    bpl.successful_processes,
    bpl.failed_processes,
    CASE 
        WHEN bpl.total_workers_processed > 0 THEN 
            ROUND((bpl.successful_processes::DECIMAL / bpl.total_workers_processed) * 100, 2)
        ELSE 0 
    END as success_rate_percent,
    bpl.processing_status,
    array_length(bpl.error_messages, 1) as error_count,
    bpl.processing_notes,
    bpl.created_at
FROM batch_processing_logs bpl
ORDER BY bpl.created_at DESC;

-- 14-3. 4대보험 액션 대기 현황 뷰
CREATE OR REPLACE VIEW v_pending_insurance_actions AS
SELECT 
    w.worker_id,
    w.name as worker_name,
    w.employee_number,
    c.company_name,
    
    CASE WHEN ier.np_action_required IN ('acquire', 'lose') THEN ier.np_action_required ELSE NULL END as np_action,
    CASE WHEN ier.hi_action_required IN ('acquire', 'lose') THEN ier.hi_action_required ELSE NULL END as hi_action,
    CASE WHEN ier.ei_action_required IN ('acquire', 'lose') THEN ier.ei_action_required ELSE NULL END as ei_action,
    CASE WHEN ier.wc_action_required IN ('acquire', 'lose') THEN ier.wc_action_required ELSE NULL END as wc_action,
    
    ier.rolling_period_start,
    ier.rolling_period_end,
    ier.work_days,
    ier.work_hours,
    ier.monthly_income,
    
    ier.np_reason,
    ier.hi_reason,
    ier.ei_reason,
    ier.wc_reason,
    
    ier.processing_status,
    ier.created_at as judgment_date
    
FROM insurance_eligibility_records ier
JOIN workers w ON ier.worker_id = w.worker_id
JOIN companies c ON w.company_id = c.company_id
WHERE ier.processing_status = 'pending'
  AND (ier.np_action_required IN ('acquire', 'lose') OR
       ier.hi_action_required IN ('acquire', 'lose') OR
       ier.ei_action_required IN ('acquire', 'lose') OR
       ier.wc_action_required IN ('acquire', 'lose'))
ORDER BY ier.created_at DESC;

-- ===============================
-- 15. 추가 인덱스 (paste.txt 기반)
-- ===============================

-- 일용직 관련 인덱스
CREATE INDEX IF NOT EXISTS idx_daily_worker_continuous_periods_worker_active ON daily_worker_continuous_periods(worker_id, is_active);
CREATE INDEX IF NOT EXISTS idx_daily_worker_continuous_periods_dates ON daily_worker_continuous_periods(continuous_start_date, continuous_end_date);
CREATE INDEX IF NOT EXISTS idx_insurance_eligibility_records_rolling ON insurance_eligibility_records(worker_id, rolling_period_start, judgment_type);
CREATE INDEX IF NOT EXISTS idx_attendance_records_worker_date ON attendance_records(worker_id, work_date);
CREATE INDEX IF NOT EXISTS idx_current_insurance_status_next_judgment ON current_insurance_status(next_judgment_date) WHERE next_judgment_date IS NOT NULL;

-- 배치 처리 관련 인덱스
CREATE INDEX IF NOT EXISTS idx_batch_processing_logs_type_date ON batch_processing_logs(batch_type, batch_date);
CREATE INDEX IF NOT EXISTS idx_insurance_acquisitions_losses_auto ON insurance_acquisitions_losses(auto_generated, created_at);

-- ===============================
-- 16. 사용 예시 및 테스트
-- ===============================

/*
-- 🎯 사용 예시:

-- === 기본 상태 관리 ===
-- 1. 사용자 컨텍스트 설정 (야해마트 = user_id 34)
SELECT set_current_user_context(34);

-- 2. 현재 사용자 상태 확인
SELECT * FROM get_user_entity_status();

-- 3. 권한 정보 조회
SELECT * FROM get_current_user_permissions();

-- 4. 전체 엔터티 상태 현황
SELECT * FROM get_entity_status_summary();

-- 5. 회사 비활성화 (하위 근로자들도 자동 비활성화)
SELECT deactivate_entity('company', 123, '계약 일시정지');

-- 6. 근로자 개별 활성화
SELECT activate_entity('worker', 456, '복직');

-- 7. 효과적 상태 확인
SELECT get_effective_status('worker', 456);

-- === 일용직 4대보험 시스템 ===
-- 8. 일용직 연속 근무 기간 업데이트
SELECT update_daily_worker_continuous_periods(456, '2025-06-04');

-- 9. 롤링 월별 자격 판정
SELECT process_rolling_monthly_insurance_eligibility(456, '2025-06-04');

-- 10. 일일 배치 처리 실행
SELECT run_daily_rolling_monthly_batch('2025-06-03');

-- 11. 대기중인 액션 처리
SELECT process_pending_insurance_actions();

-- 12. 일용직 현황 조회
SELECT * FROM v_daily_worker_insurance_status;

-- 13. 배치 처리 모니터링
SELECT * FROM v_batch_processing_monitor;

-- 14. 대기중인 액션 조회
SELECT * FROM v_pending_insurance_actions;

-- === 이메일 인증 시스템 ===
-- 15. 인증 토큰 생성
SELECT create_verification_token(34, 'registration', '127.0.0.1'::inet, 'Mozilla/5.0');

-- 16. 토큰 유효성 확인
SELECT is_verification_token_valid(34, 'your_token_here');

-- 17. 이메일 인증 완료
SELECT complete_email_verification(34, 'your_token_here');

-- 18. 만료된 토큰 정리
SELECT cleanup_expired_verification_tokens();

-- 19. 로그인 횟수 증가
SELECT increment_login_count(34);

-- 8. 컨텍스트 정리
SELECT clear_user_context();

-- 🔍 야해마트 테스트:
SELECT set_current_user_context(34);
SELECT entity_type, entity_status, effective_status, message FROM get_user_entity_status();
SELECT clear_user_context();
*/

-- 상태값 설명:
-- active: 정상 활성 상태, 모든 기능 이용 가능
-- inactive: 일시 비활성 상태, 로그인 및 일부 기능 제한 (복구 가능)
-- terminated: 완전 종료 상태, 모든 기능 차단 (복구 어려움)










-- ===============================
-- 4대보험 시스템 통일된 엔터티 상태 관리 시스템 (수정된 완전 버전)
-- 야해마트 상태 변경 문제 해결 포함
-- ===============================

-- ===============================
-- 1. 테이블 스키마 수정 (상태값 통일)
-- ===============================

-- 1-1. 노무사 사무실 상태 통일
ALTER TABLE labor_offices 
    DROP CONSTRAINT IF EXISTS labor_offices_office_status_check;

ALTER TABLE labor_offices 
    ADD CONSTRAINT labor_offices_office_status_check 
    CHECK (office_status IN ('active', 'inactive', 'terminated'));

-- 기존 데이터 마이그레이션
UPDATE labor_offices SET 
    office_status = CASE 
        WHEN office_status = 'suspended' THEN 'inactive'
        WHEN office_status = 'closed' THEN 'terminated'
        ELSE 'active'
    END;

-- 1-2. 회사 상태 통일
UPDATE companies SET 
    client_status = CASE 
        WHEN client_status = 'suspended' THEN 'inactive'
        ELSE client_status
    END;

-- 1-3. 근로자 상태 통일
ALTER TABLE workers 
    DROP CONSTRAINT IF EXISTS workers_employment_status_check;

ALTER TABLE workers 
    ADD CONSTRAINT workers_employment_status_check 
    CHECK (employment_status IN ('active', 'inactive', 'terminated'));

-- 기존 데이터 마이그레이션
UPDATE workers SET 
    employment_status = CASE 
        WHEN employment_status = 'suspended' THEN 'inactive'
        WHEN employment_status = 'resigned' THEN 'terminated'
        ELSE 'active'
    END;

-- 1-4. 노무사 직원 상태 통일
UPDATE labor_office_staff SET 
    employment_status = CASE 
        WHEN employment_status = 'suspended' THEN 'inactive'
        ELSE employment_status
    END;

-- 1-5. 사용자 상태 통일 (is_active와 user_status 통합)
-- 기존 BOOLEAN is_active를 VARCHAR user_status로 통합
ALTER TABLE users ADD COLUMN IF NOT EXISTS user_status VARCHAR(20) DEFAULT 'active';

-- 기존 데이터 마이그레이션 (is_active 기준)
UPDATE users SET 
    user_status = CASE 
        WHEN is_active = TRUE THEN 'active'
        ELSE 'inactive'
    END
WHERE user_status IS NULL OR user_status = '';

-- 제약 조건 추가
ALTER TABLE users 
    DROP CONSTRAINT IF EXISTS users_user_status_check;
    
ALTER TABLE users 
    ADD CONSTRAINT users_user_status_check 
    CHECK (user_status IN ('active', 'inactive', 'terminated'));

-- is_active 컬럼과 user_status 동기화 (기존 호환성 유지)
UPDATE users SET is_active = (user_status = 'active');

-- ===============================
-- 2. 핵심 RLS 헬퍼 함수들 (실제 구현 버전)
-- ===============================

-- 2-1. 현재 사용자 ID 조회 함수 (RLS 핵심)
CREATE OR REPLACE FUNCTION get_current_user_id()
RETURNS INTEGER AS $$
BEGIN
    RETURN COALESCE(current_setting('app.current_user_id', true)::INTEGER, 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-2. 사용자 컨텍스트 설정 함수
CREATE OR REPLACE FUNCTION set_current_user_context(user_id_param INTEGER)
RETURNS VOID AS $$
BEGIN
    PERFORM set_config('app.current_user_id', user_id_param::TEXT, false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-3. 컨텍스트 정리 함수
CREATE OR REPLACE FUNCTION clear_user_context()
RETURNS VOID AS $$
BEGIN
    PERFORM set_config('app.current_user_id', '', false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-4. 역할 확인 함수 (RLS 핵심)
CREATE OR REPLACE FUNCTION user_has_role(role_code_param TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 
        FROM user_roles ur
        JOIN roles r ON ur.role_id = r.role_id
        WHERE ur.user_id = get_current_user_id()
          AND r.role_code = role_code_param
          AND ur.is_active = true
          AND (ur.end_date IS NULL OR ur.end_date >= CURRENT_DATE)
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-5. SUPER_ADMIN 확인 함수
CREATE OR REPLACE FUNCTION is_super_admin()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN user_has_role('SUPER_ADMIN');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 호환성을 위한 별칭
CREATE OR REPLACE FUNCTION is_system_admin()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN is_super_admin();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-6. 노무사/회사 멤버 확인 함수
CREATE OR REPLACE FUNCTION is_labor_office_member()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN user_has_role('LABOR_ADMIN') OR user_has_role('LABOR_STAFF');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION is_company_member()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN user_has_role('COMPANY_ADMIN') OR user_has_role('COMPANY_HR');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-7. 소속 정보 조회 함수들
CREATE OR REPLACE FUNCTION get_user_labor_office_id()
RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT los.labor_office_id
        FROM labor_office_staff los
        WHERE los.user_id = get_current_user_id()
          AND los.employment_status = 'active'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION get_user_company_id()
RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT d.company_id
        FROM user_department_assignments uda
        JOIN departments d ON uda.department_id = d.department_id
        WHERE uda.user_id = get_current_user_id()
          AND uda.is_active = true
          AND (uda.end_date IS NULL OR uda.end_date >= CURRENT_DATE)
        LIMIT 1
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-8. 회사 접근 권한 확인 함수 (RLS 핵심)
CREATE OR REPLACE FUNCTION user_can_access_company(company_id_param INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
    v_user_id INTEGER;
    v_result BOOLEAN := FALSE;
BEGIN
    v_user_id := get_current_user_id();
    
    -- SUPER_ADMIN은 모든 회사 접근 가능
    IF is_super_admin() THEN
        RETURN TRUE;
    END IF;
    
    -- 노무사 사무실 직원인 경우: 담당 회사 확인
    IF is_labor_office_member() THEN
        SELECT EXISTS (
            SELECT 1 
            FROM user_company_assignments uca
            WHERE uca.user_id = v_user_id
              AND uca.company_id = company_id_param
              AND uca.is_active = true
              AND (uca.end_date IS NULL OR uca.end_date >= CURRENT_DATE)
        ) INTO v_result;
        
        IF v_result THEN
            RETURN TRUE;
        END IF;
    END IF;
    
    -- 회사 직원인 경우: 자신의 회사만 접근 가능
    IF is_company_member() THEN
        -- 부서 배정을 통한 회사 확인
        SELECT EXISTS (
            SELECT 1
            FROM user_department_assignments uda
            JOIN departments d ON uda.department_id = d.department_id
            WHERE uda.user_id = v_user_id
              AND d.company_id = company_id_param
              AND uda.is_active = true
              AND (uda.end_date IS NULL OR uda.end_date >= CURRENT_DATE)
        ) INTO v_result;
        
        IF v_result THEN
            RETURN TRUE;
        END IF;
        
        -- 직접 회사 배정 확인
        SELECT EXISTS (
            SELECT 1
            FROM user_company_assignments uca
            WHERE uca.user_id = v_user_id
              AND uca.company_id = company_id_param
              AND uca.is_active = true
              AND (uca.end_date IS NULL OR uca.end_date >= CURRENT_DATE)
        ) INTO v_result;
        
        RETURN v_result;
    END IF;
    
    RETURN FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-9. 부서 접근 권한 확인 함수
CREATE OR REPLACE FUNCTION user_can_access_department(department_id_param INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
    dept_company_id INTEGER;
BEGIN
    SELECT company_id INTO dept_company_id
    FROM departments
    WHERE department_id = department_id_param;
    
    RETURN user_can_access_company(dept_company_id);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2-10. 현재 사용자 권한 정보 조회
CREATE OR REPLACE FUNCTION get_current_user_permissions()
RETURNS TABLE (
    user_id INTEGER,
    username TEXT,
    roles TEXT[],
    labor_office_id INTEGER,
    company_id INTEGER,
    accessible_companies INTEGER[]
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.user_id,
        u.username::TEXT,
        ARRAY(
            SELECT r.role_code::TEXT
            FROM user_roles ur 
            JOIN roles r ON ur.role_id = r.role_id 
            WHERE ur.user_id = get_current_user_id() 
              AND ur.is_active = true
        ) as roles,
        get_user_labor_office_id() as labor_office_id,
        get_user_company_id() as company_id,
        ARRAY(
            SELECT uca.company_id 
            FROM user_company_assignments uca 
            WHERE uca.user_id = get_current_user_id() 
              AND uca.is_active = true
        ) as accessible_companies
    FROM users u
    WHERE u.user_id = get_current_user_id();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===============================
-- 3. 통일된 상태 확인 뷰 생성
-- ===============================

CREATE OR REPLACE VIEW unified_entity_status AS
SELECT 
    'labor_office' as entity_type,
    labor_office_id as entity_id,
    office_name as entity_name,
    office_status as status,
    NULL as parent_entity_type,
    NULL as parent_entity_id,
    NULL as parent_status
FROM labor_offices

UNION ALL

SELECT 
    'company' as entity_type,
    company_id as entity_id,
    company_name as entity_name,
    client_status as status,
    'labor_office' as parent_entity_type,
    labor_office_id as parent_entity_id,
    (SELECT office_status FROM labor_offices lo WHERE lo.labor_office_id = companies.labor_office_id) as parent_status
FROM companies

UNION ALL

SELECT 
    'worker' as entity_type,
    worker_id as entity_id,
    name as entity_name,
    employment_status as status,
    'company' as parent_entity_type,
    company_id as parent_entity_id,
    (SELECT client_status FROM companies c WHERE c.company_id = workers.company_id) as parent_status
FROM workers

UNION ALL

SELECT 
    'labor_staff' as entity_type,
    staff_id as entity_id,
    (SELECT name FROM users u WHERE u.user_id = labor_office_staff.user_id) as entity_name,
    employment_status as status,
    'labor_office' as parent_entity_type,
    labor_office_id as parent_entity_id,
    (SELECT office_status FROM labor_offices lo WHERE lo.labor_office_id = labor_office_staff.labor_office_id) as parent_status
FROM labor_office_staff

UNION ALL

SELECT 
    'user' as entity_type,
    user_id as entity_id,
    username as entity_name,
    user_status as status,
    NULL as parent_entity_type,
    NULL as parent_entity_id,
    NULL as parent_status
FROM users;

-- ===============================
-- 4. 통일된 상태 관리 함수들
-- ===============================

-- 4-1. 유효한 상태값 검증 함수
CREATE OR REPLACE FUNCTION is_valid_status(p_status VARCHAR(20))
RETURNS BOOLEAN AS $$
BEGIN
    RETURN p_status IN ('active', 'inactive', 'terminated');
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- 4-2. 엔터티별 효과적 상태 계산 함수
CREATE OR REPLACE FUNCTION get_effective_status(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER
) RETURNS VARCHAR(20) AS $$
DECLARE
    v_direct_status VARCHAR(20);
    v_parent_status VARCHAR(20);
    v_effective_status VARCHAR(20);
BEGIN
    -- 엔티티의 직접 상태와 부모 상태 조회
    SELECT status, parent_status 
    INTO v_direct_status, v_parent_status
    FROM unified_entity_status 
    WHERE entity_type = p_entity_type AND entity_id = p_entity_id;
    
    -- 효과적 상태 계산 (계층적 영향)
    v_effective_status := CASE
        -- 부모가 terminated면 자식도 효과적으로 terminated
        WHEN v_parent_status = 'terminated' THEN 'terminated'
        -- 부모가 inactive면 자식도 효과적으로 inactive (단, 자식이 terminated가 아닌 경우)
        WHEN v_parent_status = 'inactive' AND v_direct_status != 'terminated' THEN 'inactive'
        -- 그 외에는 자신의 직접 상태
        ELSE v_direct_status
    END;
    
    RETURN v_effective_status;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===============================
-- 5. 엔터티 상태 변경 함수들 (실제 구현 버전)
-- ===============================

-- 5-1. 통일된 엔터티 상태 변경 함수


-- 5-2. 하위 엔티티 일괄 상태 변경 함수
CREATE OR REPLACE FUNCTION public.cascade_status_change(
    p_parent_entity_type character varying, 
    p_parent_entity_id integer, 
    p_new_status character varying, 
    p_changed_by integer DEFAULT NULL::integer
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    v_affected_count INTEGER := 0;
    v_results JSONB := '[]';
    v_child_result JSONB;
    rec RECORD;
BEGIN
    -- 🏢 노무사 사무실 상태 변경시 -> 직원들에만 영향 (담당 회사는 변경 안함)
    IF p_parent_entity_type = 'labor_office' THEN
        -- ✅ 노무사 직원들 상태 변경
        FOR rec IN 
            SELECT staff_id, los.user_id, u.name as staff_name
            FROM labor_office_staff los
            JOIN users u ON los.user_id = u.user_id
            WHERE los.labor_office_id = p_parent_entity_id
              AND los.employment_status = 'active'
        LOOP
            -- 직원 상태 변경
            SELECT set_entity_status('labor_staff', rec.staff_id, p_new_status, p_changed_by, 'Cascaded from labor office')
            INTO v_child_result;
            
            v_results := v_results || v_child_result;
            v_affected_count := v_affected_count + 1;
            
            -- 해당 직원의 users 테이블도 함께 변경
            IF v_child_result->>'success' = 'true' THEN
                UPDATE users 
                SET user_status = p_new_status, 
                    is_active = (p_new_status = 'active'),
                    updated_at = CURRENT_TIMESTAMP
                WHERE user_id = rec.user_id;
                
                -- user_roles도 함께 변경
                UPDATE user_roles 
                SET is_active = (p_new_status = 'active'),
                    updated_at = CURRENT_TIMESTAMP
                WHERE user_id = rec.user_id;
            END IF;
        END LOOP;
        
        -- 담당 회사들은 상태 변경하지 않음 (비즈니스 로직에 따라)
        -- 알림도 발송하지 않음 (제거됨)
    END IF;
    
    -- 🏭 회사 상태 변경시 -> 모든 근로자에 영향
    IF p_parent_entity_type = 'company' THEN
        FOR rec IN 
            SELECT w.worker_id, w.name as worker_name, u.user_id
            FROM workers w
            LEFT JOIN users u ON w.worker_id = u.user_id  -- 근로자가 사용자 계정이 있는 경우
            WHERE w.company_id = p_parent_entity_id
              AND w.employment_status = 'active'
        LOOP
            -- 근로자 상태 변경
            SELECT set_entity_status('worker', rec.worker_id, p_new_status, p_changed_by, 'Cascaded from company')
            INTO v_child_result;
            
            v_results := v_results || v_child_result;
            v_affected_count := v_affected_count + 1;
            
            -- 근로자가 사용자 계정도 있는 경우 함께 변경
            IF rec.user_id IS NOT NULL AND v_child_result->>'success' = 'true' THEN
                UPDATE users 
                SET user_status = p_new_status, 
                    is_active = (p_new_status = 'active'),
                    updated_at = CURRENT_TIMESTAMP
                WHERE user_id = rec.user_id;
                
                -- user_roles도 함께 변경
                UPDATE user_roles 
                SET is_active = (p_new_status = 'active'),
                    updated_at = CURRENT_TIMESTAMP
                WHERE user_id = rec.user_id;
            END IF;
        END LOOP;
    END IF;
    
    -- 📊 결과 반환 (알림 관련 제거)
    RETURN jsonb_build_object(
        'parent_entity_type', p_parent_entity_type,
        'parent_entity_id', p_parent_entity_id,
        'new_status', p_new_status,
        'affected_count', v_affected_count,
        'children', v_results,
        'business_logic', CASE 
            WHEN p_parent_entity_type = 'labor_office' THEN 
                '노무사 직원들만 상태 변경됨 (담당 회사는 변경 안함)'
            WHEN p_parent_entity_type = 'company' THEN 
                '회사 근로자들 상태 변경됨'
            ELSE '기본 처리'
        END
    );
END;
$function$;

-- 5-3. 스마트 상태 변경 함수 (실제 구현 버전)


-- ===============================
-- 6. 편의 액션 함수들 (실제 구현 버전)
-- ===============================

-- 6-1. 엔터티 활성화
CREATE OR REPLACE FUNCTION activate_entity(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER,
    p_reason TEXT DEFAULT NULL
) RETURNS JSONB AS $$
BEGIN
    RETURN smart_set_entity_status(p_entity_type, p_entity_id, 'active', TRUE, p_reason);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6-2. 엔터티 비활성화
CREATE OR REPLACE FUNCTION deactivate_entity(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER,
    p_reason TEXT DEFAULT NULL
) RETURNS JSONB AS $$
BEGIN
    RETURN smart_set_entity_status(p_entity_type, p_entity_id, 'inactive', TRUE, p_reason);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6-3. 엔터티 종료
CREATE OR REPLACE FUNCTION terminate_entity(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER,
    p_reason TEXT DEFAULT NULL
) RETURNS JSONB AS $$
BEGIN
    RETURN smart_set_entity_status(p_entity_type, p_entity_id, 'terminated', TRUE, p_reason);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===============================
-- 7. 사용자 엔터티 상태 확인 함수 (야해마트 문제 해결 버전)
-- ===============================

-- 7-1. 현재 사용자의 엔터티 상태 확인 함수
CREATE OR REPLACE FUNCTION get_user_entity_status()
RETURNS TABLE (
    entity_type TEXT,
    entity_status TEXT,
    entity_id INTEGER,
    entity_name TEXT,
    message TEXT,
    role_category TEXT,
    role_code TEXT,
    effective_status TEXT
) AS $$
DECLARE
    v_user_id INTEGER;
    v_user_info RECORD;
    v_role_info RECORD;
    v_labor_office_info RECORD;
    v_company_info RECORD;
    v_worker_info RECORD;
BEGIN
    -- 현재 사용자 ID 가져오기
    v_user_id := get_current_user_id();
    
    -- 디버깅용 로그
    RAISE NOTICE '🔍 get_user_entity_status: user_id = %', v_user_id;
    
    IF v_user_id IS NULL OR v_user_id = 0 THEN
        RETURN QUERY SELECT 
            'unknown'::TEXT, 
            'inactive'::TEXT, 
            NULL::INTEGER, 
            'No User Context'::TEXT, 
            '사용자 컨텍스트가 설정되지 않았습니다.'::TEXT,
            'unknown'::TEXT,
            'unknown'::TEXT,
            'inactive'::TEXT;
        RETURN;
    END IF;

    -- 사용자 기본 정보 조회 (RLS 우회)
    SELECT u.user_id, u.username, u.name, u.is_active, u.user_status
    INTO v_user_info
    FROM users u
    WHERE u.user_id = v_user_id;
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT 
            'unknown'::TEXT, 
            'inactive'::TEXT, 
            NULL::INTEGER, 
            'User Not Found'::TEXT, 
            '사용자를 찾을 수 없습니다.'::TEXT,
            'unknown'::TEXT,
            'unknown'::TEXT,
            'inactive'::TEXT;
        RETURN;
    END IF;

    -- 역할 정보 조회 (RLS 우회를 위해 직접 쿼리)
    SELECT r.role_code, r.role_name, r.role_category
    INTO v_role_info
    FROM user_roles ur
    JOIN roles r ON ur.role_id = r.role_id
    WHERE ur.user_id = v_user_id
      AND ur.is_active = true
      AND (ur.end_date IS NULL OR ur.end_date >= CURRENT_DATE)
    ORDER BY 
        CASE 
            WHEN r.role_code = 'SUPER_ADMIN' THEN 1
            WHEN r.role_code = 'LABOR_ADMIN' THEN 2
            WHEN r.role_code = 'COMPANY_ADMIN' THEN 3
            ELSE 4
        END
    LIMIT 1;
    
    -- 디버깅용 로그
    RAISE NOTICE '🔍 Role found: % (% - %)', v_role_info.role_code, v_role_info.role_name, v_role_info.role_category;
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT 
            'user'::TEXT, 
            COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END)::TEXT, 
            v_user_info.user_id, 
            v_user_info.name::TEXT, 
            '역할이 배정되지 않았습니다.'::TEXT,
            'none'::TEXT,
            'none'::TEXT,
            COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END)::TEXT;
        RETURN;
    END IF;

    -- SUPER_ADMIN인 경우
    IF v_role_info.role_code = 'SUPER_ADMIN' THEN
        RETURN QUERY SELECT 
            'system'::TEXT, 
            'active'::TEXT, 
            v_user_info.user_id, 
            'System Administrator'::TEXT, 
            '시스템 관리자 권한으로 모든 기능에 접근 가능합니다.'::TEXT,
            'system'::TEXT,
            'SUPER_ADMIN'::TEXT,
            'active'::TEXT;
        RETURN;
    END IF;

    -- 노무사 사무실 역할인 경우
    IF v_role_info.role_category = 'labor_office' THEN
        SELECT los.labor_office_id, los.position, los.employment_status, lo.office_name, lo.office_status
        INTO v_labor_office_info
        FROM labor_office_staff los
        JOIN labor_offices lo ON los.labor_office_id = lo.labor_office_id
        WHERE los.user_id = v_user_id
          AND los.employment_status = 'active';
        
        IF FOUND THEN
            DECLARE
                v_direct_status TEXT := COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END);
                v_parent_status TEXT := v_labor_office_info.office_status;
                v_effective_status TEXT := CASE 
                    WHEN v_parent_status = 'active' THEN v_direct_status 
                    ELSE v_parent_status 
                END;
                v_message TEXT := CASE 
                    WHEN v_effective_status = 'active' THEN '모든 기능을 이용하실 수 있습니다.'
                    WHEN v_parent_status != 'active' THEN '노무사 사무실이 비활성화 상태입니다.'
                    ELSE '계정이 비활성화 상태입니다.'
                END;
            BEGIN
                RETURN QUERY SELECT 
                    'labor_office'::TEXT, 
                    v_direct_status, 
                    v_labor_office_info.labor_office_id, 
                    v_labor_office_info.office_name::TEXT, 
                    v_message,
                    'labor_office'::TEXT,
                    v_role_info.role_code::TEXT,
                    v_effective_status;
                RETURN;
            END;
        END IF;
    END IF;

    -- 회사 역할인 경우
    IF v_role_info.role_category = 'company' THEN
        -- 회사 부서 배정 확인
        SELECT d.company_id, c.company_name, c.client_status, uda.assignment_type
        INTO v_company_info
        FROM user_department_assignments uda
        JOIN departments d ON uda.department_id = d.department_id
        JOIN companies c ON d.company_id = c.company_id
        WHERE uda.user_id = v_user_id
          AND uda.is_active = true
        LIMIT 1;
        
        -- 직접 회사 배정 확인
        IF NOT FOUND THEN
            SELECT uca.company_id, c.company_name, c.client_status, uca.assignment_type
            INTO v_company_info
            FROM user_company_assignments uca
            JOIN companies c ON uca.company_id = c.company_id
            WHERE uca.user_id = v_user_id
              AND uca.is_active = true
            LIMIT 1;
        END IF;
        
        IF FOUND THEN
            DECLARE
                v_direct_status TEXT := COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END);
                v_parent_status TEXT := v_company_info.client_status;
                v_effective_status TEXT := CASE 
                    WHEN v_parent_status = 'active' THEN v_direct_status 
                    ELSE v_parent_status 
                END;
                v_message TEXT := CASE 
                    WHEN v_effective_status = 'active' THEN '모든 기능을 이용하실 수 있습니다.'
                    WHEN v_parent_status != 'active' THEN '소속 회사가 비활성화 상태입니다.'
                    ELSE '계정이 비활성화 상태입니다.'
                END;
            BEGIN
                RETURN QUERY SELECT 
                    'company'::TEXT, 
                    v_direct_status, 
                    v_company_info.company_id, 
                    v_company_info.company_name::TEXT, 
                    v_message,
                    'company'::TEXT,
                    v_role_info.role_code::TEXT,
                    v_effective_status;
                RETURN;
            END;
        END IF;
    END IF;

    -- 기본 사용자 (소속 없음)
    RETURN QUERY SELECT 
        'user'::TEXT, 
        COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END)::TEXT, 
        v_user_info.user_id, 
        v_user_info.name::TEXT, 
        CASE 
            WHEN COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END) = 'active' THEN '기본 기능을 이용하실 수 있습니다.'
            ELSE '계정이 비활성화 상태입니다.'
        END::TEXT,
        v_role_info.role_category::TEXT,
        v_role_info.role_code::TEXT,
        COALESCE(v_user_info.user_status, CASE WHEN v_user_info.is_active THEN 'active' ELSE 'inactive' END)::TEXT;
    
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- 📁 알림 기능 제거된 cascade_status_change 함수
CREATE OR REPLACE FUNCTION public.cascade_status_change(
    p_parent_entity_type character varying, 
    p_parent_entity_id integer, 
    p_new_status character varying, 
    p_changed_by integer DEFAULT NULL::integer
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    v_affected_count INTEGER := 0;
    v_results JSONB := '[]';
    v_child_result JSONB;
    rec RECORD;
BEGIN
    -- 🏢 노무사 사무실 상태 변경시 -> 직원들에만 영향 (담당 회사는 변경 안함)
    IF p_parent_entity_type = 'labor_office' THEN
        -- ✅ 노무사 직원들 상태 변경
        FOR rec IN 
            SELECT staff_id, los.user_id, u.name as staff_name
            FROM labor_office_staff los
            JOIN users u ON los.user_id = u.user_id
            WHERE los.labor_office_id = p_parent_entity_id
              AND los.employment_status = 'active'
        LOOP
            -- 직원 상태 변경
            SELECT set_entity_status('labor_staff', rec.staff_id, p_new_status, p_changed_by, 'Cascaded from labor office')
            INTO v_child_result;
            
            v_results := v_results || v_child_result;
            v_affected_count := v_affected_count + 1;
            
            -- 해당 직원의 users 테이블도 함께 변경
            IF v_child_result->>'success' = 'true' THEN
                UPDATE users 
                SET user_status = p_new_status, 
                    is_active = (p_new_status = 'active'),
                    updated_at = CURRENT_TIMESTAMP
                WHERE user_id = rec.user_id;
                
                -- user_roles도 함께 변경
                UPDATE user_roles 
                SET is_active = (p_new_status = 'active'),
                    updated_at = CURRENT_TIMESTAMP
                WHERE user_id = rec.user_id;
            END IF;
        END LOOP;
        
        -- 담당 회사들은 상태 변경하지 않음 (비즈니스 로직에 따라)
        -- 알림도 발송하지 않음 (제거됨)
    END IF;
    
    -- 🏭 회사 상태 변경시 -> 모든 근로자에 영향
    IF p_parent_entity_type = 'company' THEN
        FOR rec IN 
            SELECT w.worker_id, w.name as worker_name, u.user_id
            FROM workers w
            LEFT JOIN users u ON w.worker_id = u.user_id  -- 근로자가 사용자 계정이 있는 경우
            WHERE w.company_id = p_parent_entity_id
              AND w.employment_status = 'active'
        LOOP
            -- 근로자 상태 변경
            SELECT set_entity_status('worker', rec.worker_id, p_new_status, p_changed_by, 'Cascaded from company')
            INTO v_child_result;
            
            v_results := v_results || v_child_result;
            v_affected_count := v_affected_count + 1;
            
            -- 근로자가 사용자 계정도 있는 경우 함께 변경
            IF rec.user_id IS NOT NULL AND v_child_result->>'success' = 'true' THEN
                UPDATE users 
                SET user_status = p_new_status, 
                    is_active = (p_new_status = 'active'),
                    updated_at = CURRENT_TIMESTAMP
                WHERE user_id = rec.user_id;
                
                -- user_roles도 함께 변경
                UPDATE user_roles 
                SET is_active = (p_new_status = 'active'),
                    updated_at = CURRENT_TIMESTAMP
                WHERE user_id = rec.user_id;
            END IF;
        END LOOP;
    END IF;
    
    -- 📊 결과 반환 (알림 관련 제거)
    RETURN jsonb_build_object(
        'parent_entity_type', p_parent_entity_type,
        'parent_entity_id', p_parent_entity_id,
        'new_status', p_new_status,
        'affected_count', v_affected_count,
        'children', v_results,
        'business_logic', CASE 
            WHEN p_parent_entity_type = 'labor_office' THEN 
                '노무사 직원들만 상태 변경됨 (담당 회사는 변경 안함)'
            WHEN p_parent_entity_type = 'company' THEN 
                '회사 근로자들 상태 변경됨'
            ELSE '기본 처리'
        END
    );
END;
$function$;

-- 📁 알림 테이블 및 관련 함수들 제거
-- 1. 알림 테이블 제거
DROP TABLE IF EXISTS labor_office_service_notifications CASCADE;

-- 2. 알림 관련 함수들 제거
DROP FUNCTION IF EXISTS get_company_unread_notification_count(integer);
DROP FUNCTION IF EXISTS mark_notification_as_read(bigint);

-- 📁 smart_set_entity_status 함수도 알림 관련 부분 제거하여 수정
CREATE OR REPLACE FUNCTION public.smart_set_entity_status(
    p_entity_type character varying, 
    p_entity_id integer, 
    p_new_status character varying, 
    p_cascade boolean DEFAULT true, 
    p_reason text DEFAULT NULL::text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    v_main_result JSONB;
    v_cascade_result JSONB;
    v_final_result JSONB;
    v_user_context INTEGER;
BEGIN
    -- 현재 사용자 컨텍스트 확인
    v_user_context := get_current_user_id();
    
    RAISE NOTICE '🔍 smart_set_entity_status: entity_type=%, entity_id=%, new_status=%, cascade=%, user=%', 
        p_entity_type, p_entity_id, p_new_status, p_cascade, v_user_context;
    
    -- 1. 메인 엔티티 상태 변경
    SELECT set_entity_status(p_entity_type, p_entity_id, p_new_status, v_user_context, p_reason)
    INTO v_main_result;
    
    -- 실패시 즉시 반환
    IF NOT (v_main_result->>'success')::BOOLEAN THEN
        RETURN v_main_result || jsonb_build_object(
            'cascade_applied', false,
            'cascade_reason', 'Main entity update failed'
        );
    END IF;
    
    -- 2. 계층적 영향 처리 (요청된 경우만)
    IF p_cascade THEN
        -- 비활성화나 종료 시에만 cascade 적용
        IF p_new_status IN ('inactive', 'terminated') THEN
            SELECT cascade_status_change(p_entity_type, p_entity_id, p_new_status, v_user_context)
            INTO v_cascade_result;
            
            RAISE NOTICE '✅ Cascade applied: affected_count=%', 
                v_cascade_result->>'affected_count';
        
        -- 활성화 시에는 cascade 하지 않음 (수동으로 개별 복구해야 함)
        ELSE
            v_cascade_result := jsonb_build_object(
                'affected_count', 0,
                'reason', 'Activation does not cascade automatically - manual recovery required'
            );
            
            RAISE NOTICE '⚠️ Activation cascade skipped - manual recovery required';
        END IF;
    ELSE
        v_cascade_result := jsonb_build_object(
            'affected_count', 0,
            'reason', 'Cascade disabled by parameter'
        );
        
        RAISE NOTICE '🔄 Cascade disabled by parameter';
    END IF;
    
    -- 3. 최종 결과 구성 (알림 관련 제거)
    v_final_result := v_main_result || jsonb_build_object(
        'cascade_applied', p_cascade,
        'cascade_results', v_cascade_result,
        'processing_notes', CASE 
            WHEN p_new_status = 'active' AND p_cascade THEN 
                '활성화는 자동 전파되지 않습니다. 하위 엔터티는 수동으로 복구해야 합니다.'
            WHEN p_new_status IN ('inactive', 'terminated') AND p_cascade THEN 
                '비활성화/종료가 하위 엔터티에 전파되었습니다.'
            ELSE '단일 엔터티만 변경되었습니다.'
        END
    );
    
    RETURN v_final_result;
END;
$function$;



-- ===============================
-- 8. 상태 조회 및 분석 함수들
-- ===============================

-- 8-1. 전체 엔터티 상태 현황 조회
CREATE OR REPLACE FUNCTION get_entity_status_summary()
RETURNS TABLE (
    entity_type VARCHAR(20),
    active_count BIGINT,
    inactive_count BIGINT,
    terminated_count BIGINT,
    total_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ues.entity_type,
        COUNT(*) FILTER (WHERE ues.status = 'active') as active_count,
        COUNT(*) FILTER (WHERE ues.status = 'inactive') as inactive_count,
        COUNT(*) FILTER (WHERE ues.status = 'terminated') as terminated_count,
        COUNT(*) as total_count
    FROM unified_entity_status ues
    GROUP BY ues.entity_type
    ORDER BY ues.entity_type;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 8-2. 특정 엔터티 상세 상태 조회
CREATE OR REPLACE FUNCTION get_entity_detailed_status(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER
) RETURNS JSONB AS $$
DECLARE
    v_entity_info RECORD;
    v_children JSONB := '[]';
    v_result JSONB;
    rec RECORD;
BEGIN
    -- 기본 엔터티 정보 조회
    SELECT * INTO v_entity_info
    FROM unified_entity_status 
    WHERE entity_type = p_entity_type AND entity_id = p_entity_id;
    
    -- 하위 엔터티들 조회
    IF p_entity_type = 'labor_office' THEN
        -- 노무사 직원들과 담당 회사들
        FOR rec IN 
            SELECT entity_type, entity_id, entity_name, status
            FROM unified_entity_status 
            WHERE parent_entity_type = 'labor_office' 
              AND parent_entity_id = p_entity_id
        LOOP
            v_children := v_children || to_jsonb(rec);
        END LOOP;
        
    ELSIF p_entity_type = 'company' THEN
        -- 회사 근로자들
        FOR rec IN 
            SELECT entity_type, entity_id, entity_name, status
            FROM unified_entity_status 
            WHERE parent_entity_type = 'company' 
              AND parent_entity_id = p_entity_id
        LOOP
            v_children := v_children || to_jsonb(rec);
        END LOOP;
    END IF;
    
    -- 결과 구성
    v_result := to_jsonb(v_entity_info) || jsonb_build_object(
        'effective_status', get_effective_status(p_entity_type, p_entity_id),
        'children', v_children,
        'children_count', jsonb_array_length(v_children)
    );
    
    RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 8-3. 사용자 엔터티 활성 상태 확인
CREATE OR REPLACE FUNCTION is_user_entity_active()
RETURNS BOOLEAN AS $$
DECLARE
    user_status RECORD;
BEGIN
    SELECT * INTO user_status FROM get_user_entity_status() LIMIT 1;
    
    -- system 카테고리는 항상 활성
    IF user_status.role_category = 'system' THEN
        RETURN TRUE;
    END IF;
    
    -- 효과적 상태 기준으로 판단
    RETURN user_status.effective_status = 'active';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 8-4. 엔터티 접근 가능 여부 확인
CREATE OR REPLACE FUNCTION entity_is_accessible(
    p_entity_type VARCHAR(20),
    p_entity_id INTEGER
) RETURNS BOOLEAN AS $$
DECLARE
    v_effective_status VARCHAR(20);
BEGIN
    -- SUPER_ADMIN은 모든 상태의 엔터티 접근 가능
    IF is_super_admin() THEN
        RETURN TRUE;
    END IF;
    
    -- 일반 사용자는 terminated 엔터티 접근 불가
    v_effective_status := get_effective_status(p_entity_type, p_entity_id);
    
    RETURN v_effective_status != 'terminated';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 8-5. 활성 사용자 확인 함수 업데이트
CREATE OR REPLACE FUNCTION user_is_active()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM users 
        WHERE user_id = get_current_user_id() 
          AND (user_status = 'active' OR (user_status IS NULL AND is_active = TRUE))
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===============================
-- 9. 엔터티 상태 상세 정보 함수들
-- ===============================

-- 9-1. 엔터티 상태 상세 정보 조회
CREATE OR REPLACE FUNCTION get_entity_status_details()
RETURNS TABLE (
    entity_type TEXT,
    entity_status TEXT,
    entity_name TEXT,
    status_message TEXT,
    can_access BOOLEAN,
    restricted_features TEXT[],
    admin_contact TEXT,
    role_category TEXT,
    role_code TEXT,
    effective_status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ues.entity_type,
        ues.entity_status,
        ues.entity_name,
        ues.message as status_message,
        CASE 
            WHEN ues.role_category = 'system' THEN true
            ELSE (ues.effective_status = 'active')
        END as can_access,
        CASE 
            WHEN ues.role_category = 'system' THEN ARRAY[]::TEXT[]
            WHEN ues.effective_status = 'inactive' THEN 
                ARRAY['data_modification', 'report_generation', 'setting_changes']::TEXT[]
            WHEN ues.effective_status = 'terminated' THEN 
                ARRAY['data_modification', 'report_generation', 'setting_changes', 'data_view']::TEXT[]
            ELSE ARRAY[]::TEXT[]
        END as restricted_features,
        CASE 
            WHEN ues.entity_type = 'labor_office' THEN '노무사 사무실 관리자에게 문의하세요.'::TEXT
            WHEN ues.entity_type = 'company' THEN '회사 관리자에게 문의하세요.'::TEXT
            WHEN ues.entity_type = 'worker' THEN '회사 인사담당자에게 문의하세요.'::TEXT
            WHEN ues.entity_type = 'system' THEN '시스템이 정상 작동 중입니다.'::TEXT
            ELSE '시스템 관리자에게 문의하세요.'::TEXT
        END as admin_contact,
        ues.role_category,
        ues.role_code,
        ues.effective_status
    FROM get_user_entity_status() ues;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ===============================
-- 10. 성능 최적화 인덱스
-- ===============================

-- 상태 기반 조회 최적화
CREATE INDEX IF NOT EXISTS idx_labor_offices_status ON labor_offices(office_status);
CREATE INDEX IF NOT EXISTS idx_companies_status ON companies(client_status);
CREATE INDEX IF NOT EXISTS idx_workers_status ON workers(employment_status);
CREATE INDEX IF NOT EXISTS idx_labor_staff_status ON labor_office_staff(employment_status);
CREATE INDEX IF NOT EXISTS idx_users_status ON users(user_status);
CREATE INDEX IF NOT EXISTS idx_users_is_active ON users(is_active);

-- 계층 관계 조회 최적화
CREATE INDEX IF NOT EXISTS idx_companies_labor_office ON companies(labor_office_id, client_status);
CREATE INDEX IF NOT EXISTS idx_workers_company ON workers(company_id, employment_status);
CREATE INDEX IF NOT EXISTS idx_labor_staff_office ON labor_office_staff(labor_office_id, employment_status);

-- RLS 함수 최적화
CREATE INDEX IF NOT EXISTS idx_user_roles_user_active ON user_roles(user_id, is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_user_company_assignments_active ON user_company_assignments(user_id, company_id, is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_user_department_assignments_active ON user_department_assignments(user_id, is_active) WHERE is_active = true;

-- ===============================
-- 11. 함수 설명 및 주석
-- ===============================

COMMENT ON FUNCTION get_current_user_id() IS '현재 로그인한 사용자 ID 조회 (세션 변수 기반, RLS 핵심)';
COMMENT ON FUNCTION set_current_user_context(INTEGER) IS '사용자 로그인 시 컨텍스트 설정 (애플리케이션에서 호출)';
COMMENT ON FUNCTION user_has_role(TEXT) IS '현재 사용자가 특정 역할을 가지고 있는지 확인 (RLS 핵심)';
COMMENT ON FUNCTION is_super_admin() IS 'SUPER_ADMIN 권한 확인 (모든 데이터 접근 가능)';
COMMENT ON FUNCTION user_can_access_company(INTEGER) IS '현재 사용자가 특정 회사에 접근 가능한지 확인 (RLS 핵심)';
COMMENT ON FUNCTION set_entity_status(VARCHAR, INTEGER, VARCHAR, INTEGER, TEXT) IS '통일된 엔터티 상태 변경 함수 (active, inactive, terminated)';
COMMENT ON FUNCTION get_effective_status(VARCHAR, INTEGER) IS '계층적 관계를 고려한 실제 유효 상태 계산';
COMMENT ON FUNCTION smart_set_entity_status(VARCHAR, INTEGER, VARCHAR, BOOLEAN, TEXT) IS '하위 엔터티 자동 처리를 포함한 스마트 상태 변경';
COMMENT ON FUNCTION get_user_entity_status() IS '현재 사용자의 소속 엔터티 상태 확인 (야해마트 문제 해결 포함)';
COMMENT ON FUNCTION activate_entity(VARCHAR, INTEGER, TEXT) IS '엔터티 활성화 편의 함수';
COMMENT ON FUNCTION deactivate_entity(VARCHAR, INTEGER, TEXT) IS '엔터티 비활성화 편의 함수';
COMMENT ON FUNCTION terminate_entity(VARCHAR, INTEGER, TEXT) IS '엔터티 종료 편의 함수';
COMMENT ON VIEW unified_entity_status IS '모든 엔터티의 통일된 상태 조회 뷰 (계층 관계 포함)';


-- 4. 함수 소유권 및 권한 설정
ALTER FUNCTION set_entity_status(VARCHAR, INTEGER, VARCHAR, INTEGER, TEXT) OWNER TO postgres;
ALTER FUNCTION user_can_access_company(INTEGER) OWNER TO postgres;

GRANT EXECUTE ON FUNCTION set_entity_status(VARCHAR, INTEGER, VARCHAR, INTEGER, TEXT) TO PUBLIC;
GRANT EXECUTE ON FUNCTION user_can_access_company(INTEGER) TO PUBLIC;

-- 5. 테스트용 권한 확인 함수 업데이트
CREATE OR REPLACE FUNCTION test_hierarchical_permissions(
    user_id_param INTEGER,
    target_entity_type VARCHAR(20),
    target_entity_id INTEGER
)
RETURNS JSONB AS $$
DECLARE
    v_result JSONB;
    v_original_context INTEGER;
BEGIN
    -- 현재 컨텍스트 백업
    v_original_context := get_current_user_id();
    
    -- 테스트할 사용자로 컨텍스트 설정
    PERFORM set_current_user_context(user_id_param);
    
    -- 권한 테스트
    v_result := jsonb_build_object(
        'test_user_id', user_id_param,
        'target_entity_type', target_entity_type,
        'target_entity_id', target_entity_id,
        'current_context_user_id', get_current_user_id(),
        'is_super_admin', is_super_admin(),
        'is_labor_office_member', is_labor_office_member(),
        'is_company_member', is_company_member(),
        'user_labor_office_id', get_user_labor_office_id(),
        'user_company_id', get_user_company_id(),
        'user_roles', (
            SELECT json_agg(r.role_code)
            FROM user_roles ur
            JOIN roles r ON ur.role_id = r.role_id
            WHERE ur.user_id = user_id_param
              AND ur.is_active = true
        )
    );
    
    -- 엔터티 타입별 접근 권한 확인
    IF target_entity_type = 'company' THEN
        v_result := v_result || jsonb_build_object(
            'can_access_target_company', user_can_access_company(target_entity_id)
        );
    END IF;
    
    -- 컨텍스트 복원
    IF v_original_context > 0 THEN
        PERFORM set_current_user_context(v_original_context);
    ELSE
        PERFORM clear_user_context();
    END IF;
    
    RETURN v_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION test_hierarchical_permissions(INTEGER, VARCHAR, INTEGER) TO PUBLIC;

-- 6. 사용 예시 및 테스트 쿼리
/*
-- 관리자 권한 테스트 (user_id = 27이 SUPER_ADMIN인 경우)
SELECT test_hierarchical_permissions(27, 'user', 34);

-- 실제 상태 변경 테스트
SELECT set_current_user_context(27);
SELECT set_entity_status('user', 34, 'inactive', 27, '계층적 권한 테스트');
SELECT clear_user_context();

-- 결과 확인
SELECT user_id, username, name, is_active, user_status 
FROM users WHERE user_id = 34;

-- 다른 역할들의 권한 테스트 (LABOR_ADMIN, COMPANY_ADMIN 등)
-- SELECT test_hierarchical_permissions(다른_사용자_ID, 'company', 타겟_회사_ID);
*/




-- ===============================
-- 12. 사용 예시 및 테스트
-- ===============================

/*
-- 🎯 사용 예시:

-- 1. 사용자 컨텍스트 설정 (야해마트 = user_id 34)
SELECT set_current_user_context(34);

-- 2. 현재 사용자 상태 확인
SELECT * FROM get_user_entity_status();

-- 3. 권한 정보 조회
SELECT * FROM get_current_user_permissions();

-- 4. 전체 엔터티 상태 현황
SELECT * FROM get_entity_status_summary();

-- 5. 회사 비활성화 (하위 근로자들도 자동 비활성화)
SELECT deactivate_entity('company', 123, '계약 일시정지');

-- 6. 근로자 개별 활성화
SELECT activate_entity('worker', 456, '복직');

-- 7. 효과적 상태 확인
SELECT get_effective_status('worker', 456);

-- 8. 컨텍스트 정리
SELECT clear_user_context();

-- 🔍 야해마트 테스트:
SELECT set_current_user_context(34);
SELECT entity_type, entity_status, effective_status, message FROM get_user_entity_status();
SELECT clear_user_context();
*/

-- 상태값 설명:
-- active: 정상 활성 상태, 모든 기능 이용 가능
-- inactive: 일시 비활성 상태, 로그인 및 일부 기능 제한 (복구 가능)
-- terminated: 완전 종료 상태, 모든 기능 차단 (복구 어려움)




















-- ===============================
-- 기본 데이터 입력 (확장됨)
-- ===============================

-- 기본 역할 정의
INSERT INTO roles (role_code, role_name, role_category, permissions, description, is_system_role) VALUES 
('LABOR_ADMIN', '노무사 사무실 관리자', 'labor_office', 
 '{"users": ["read", "write"], "companies": ["read", "write"], "workers": ["read", "write"], "insurance": ["read", "write"], "payroll": ["read", "write"], "reports": ["read", "write"]}',
 '노무사 사무실의 모든 기능을 관리할 수 있는 관리자', TRUE),
('LABOR_STAFF', '노무사 사무실 직원', 'labor_office',
 '{"companies": ["read", "write"], "workers": ["read", "write"], "insurance": ["read", "write"], "payroll": ["read"], "reports": ["read", "write"]}',
 '담당 고객사의 4대보험 업무를 처리하는 직원', TRUE),
('COMPANY_ADMIN', '회사 관리자', 'company',
 '{"workers": ["read", "write"], "attendance": ["read", "write"], "payroll": ["read"], "insurance": ["read"], "departments": ["read", "write"]}',
 '회사의 인사 및 급여 업무를 총괄하는 관리자', TRUE),
('COMPANY_HR', '인사담당자', 'company',
 '{"workers": ["read", "write"], "attendance": ["read", "write"], "payroll": ["read"], "insurance": ["read"]}',
 '인사 업무를 담당하는 직원', TRUE);

-- 급여 항목 마스터 데이터
INSERT INTO payroll_item_types (item_code, default_name, item_category, tax_type, insurance_included, calculation_method, nontax_limit_type, description, sort_order) VALUES 
-- 기본급
('BASE_SALARY', '기본급', 'basic_pay', 'taxable', TRUE, 'fixed', NULL, '월 기본 급여', 10),

-- 과세 수당
('POSITION_ALLOWANCE', '직책수당', 'allowance', 'taxable', TRUE, 'fixed', NULL, '직책에 따른 수당', 20),
('SKILL_ALLOWANCE', '기술수당', 'allowance', 'taxable', TRUE, 'fixed', NULL, '기술/자격에 따른 수당', 30),
('HAZARD_ALLOWANCE', '위험수당', 'allowance', 'taxable', TRUE, 'fixed', NULL, '위험한 업무에 대한 수당', 40),

-- 근무시간 관련 수당
('OVERTIME_PAY', '연장근로수당', 'overtime', 'taxable', TRUE, 'hourly', NULL, '법정 연장근로에 대한 수당', 50),
('NIGHT_PAY', '야간근로수당', 'overtime', 'taxable', TRUE, 'hourly', NULL, '야간 근무에 대한 수당', 60),
('HOLIDAY_PAY', '휴일근로수당', 'overtime', 'taxable', TRUE, 'hourly', NULL, '휴일 근무에 대한 수당', 70),

-- 비과세 수당
('MEAL_ALLOWANCE', '식대', 'allowance', 'nontax', FALSE, 'fixed', 'meal_allowance', '식사비 지원', 100),
('TRANSPORT_ALLOWANCE', '교통비', 'allowance', 'nontax', FALSE, 'fixed', 'transport_allowance', '교통비 지원', 110),
('CAR_MAINTENANCE', '자가운전보조금', 'allowance', 'nontax', FALSE, 'fixed', 'car_maintenance', '자차 운전 보조금', 120);

-- 비과세 한도 기본 데이터
INSERT INTO nontax_limits (company_id, limit_type, limit_name, monthly_limit, annual_limit, effective_date, is_legal_limit, legal_reference, description) VALUES 
(NULL, 'meal_allowance', '식대', 200000, 2400000, '2024-01-01', TRUE, '소득세법 시행령 제12조', '법정 식대 비과세 한도'),
(NULL, 'transport_allowance', '교통비', 200000, 2400000, '2024-01-01', TRUE, '소득세법 시행령 제12조', '법정 교통비 비과세 한도'),
(NULL, 'car_maintenance', '자가운전보조금', 200000, 2400000, '2024-01-01', TRUE, '소득세법 시행령 제12조', '법정 자가운전보조금 비과세 한도');

-- 고용형태별 기본 데이터 (롤링 월별 판정 포함)
INSERT INTO employment_types (type_code, type_name, type_category, judgment_method, np_criteria, hi_criteria, ei_criteria, wc_criteria, np_voluntary_allowed, hi_voluntary_allowed, ei_voluntary_allowed, legal_definition) VALUES 
('REGULAR', '정규직', 'regular', 'immediate',
 '{"immediate": true}', '{"immediate": true}', '{"immediate": true}', '{"immediate": true}',
 FALSE, FALSE, FALSE, '기간의 정함이 없는 근로계약을 체결한 근로자'),
('CONTRACT', '계약직', 'contract', 'immediate',
 '{"immediate": true}', '{"immediate": true}', '{"immediate": true}', '{"immediate": true}',
 FALSE, FALSE, FALSE, '기간의 정함이 있는 근로계약을 체결한 근로자'),
('PART_TIME', '단시간근로자', 'part_time', 'monthly',
 '{"min_hours_monthly": 60, "min_employment_months": 1, "min_monthly_income": 2200000}',
 '{"min_hours_monthly": 60}', '{"min_hours_monthly": 60, "min_employment_months": 3}', '{"min_days": 1}',
 TRUE, TRUE, TRUE, '1주 동안의 소정근로시간이 통상근로자의 소정근로시간에 비해 짧은 근로자'),
('DAILY', '일용직', 'daily', 'rolling_monthly',
 '{"min_days_monthly": 8, "min_hours_monthly": 60, "min_monthly_income": 2200000}',
 '{"min_days_monthly": 8, "min_hours_monthly": 60}', '{"min_days": 1}', '{"min_days": 1}',
 TRUE, TRUE, TRUE, '1개월 미만의 기간으로 고용되어 일급 형태로 보수를 받는 근로자');

-- 4대보험 요율 기본 데이터
INSERT INTO insurance_rates (apply_year, apply_month, effective_date, is_active) VALUES 
(2025, 1, '2025-01-01', TRUE);

-- 사유코드 기본 데이터
INSERT INTO insurance_reason_codes (insurance_type, transaction_type, reason_code, reason_name, description, required_documents) VALUES 
('NP', 'acquisition', '10', '일반취득', '일반적인 국민연금 취득', ARRAY['근로계약서', '주민등록등본']),
('NP', 'acquisition', '15', '선택가입', '국민연금 선택가입', ARRAY['근로계약서', '선택가입신청서', '사업주동의서']),
('NP', 'loss', '20', '일반상실', '일반적인 국민연금 상실', ARRAY['퇴직증명서']),
('HI', 'acquisition', '10', '일반취득', '일반적인 건강보험 취득', ARRAY['근로계약서']),
('EI', 'acquisition', '10', '일반취득', '일반적인 고용보험 취득', ARRAY['근로계약서']),
('WC', 'acquisition', '10', '일반취득', '일반적인 산재보험 취득', ARRAY['근로계약서']);

-- ===============================
-- 시스템 특징 및 사용 가이드
-- ===============================

/*
=== 4대보험 취득상실 통합 관리 시스템 - 완전 최종 버전 ===
=== 일용직 롤링 월별 판정 및 배치 처리 시스템 완성 ===

🎯 **핵심 개선사항 (paste-2.txt 반영):**

1. **일용직 롤링 월별 판정 시스템**
   - daily_worker_continuous_periods: 연속 근무 기간 추적
   - process_rolling_monthly_insurance_eligibility: 개별 판정 함수
   - run_daily_rolling_monthly_batch: 일일 배치 처리
   - 이벤트 기반 실시간 판정 트리거

2. **배치 처리 시스템**
   - batch_processing_logs: 모든 배치 작업 로깅
   - 성공/실패율 추적 및 오류 메시지 관리
   - 스케줄러와 연동 가능한 구조

3. **자동화된 신고 생성**
   - process_pending_insurance_actions: 대기중 액션 자동 처리
   - insurance_acquisitions_losses에 자동 신고 레코드 생성
   - auto_generated 플래그로 수동/자동 구분

💡 **주요 활용 시나리오:**

1. **일일 배치 실행 (매일 새벽 2시)**
   ```sql
   SELECT run_daily_rolling_monthly_batch();
   ```

2. **특정 일용직 즉시 판정**
   ```sql
   SELECT process_rolling_monthly_insurance_eligibility(근로자ID, 판정일);
   ```

3. **배치 처리 모니터링**
   ```sql
   SELECT * FROM v_batch_processing_monitor WHERE batch_date = CURRENT_DATE;
   ```

4. **대기중인 신고 현황 확인**
   ```sql
   SELECT * FROM v_pending_insurance_actions;
   ```

🚀 **시스템 장점:**

✅ **완전 자동화**
- 일용직 4대보험 판정 완전 자동화
- 연속 근무 기간 자동 추적
- 배치 처리 및 오류 관리 자동화

✅ **실시간 처리**
- 근태 입력시 즉시 재판정
- 연속 근무 기간 실시간 업데이트
- 필요시 즉시 신고 생성

✅ **완벽한 추적성**
- 모든 판정 과정 기록
- 배치 처리 로그 완전 관리
- 오류 발생시 상세 추적 가능

✅ **유연한 확장성**
- 새로운 배치 작업 쉽게 추가
- 고용형태별 판정 방식 확장 가능
- 급여 항목 및 비과세 한도 완전 유연

🔧 **운영 가이드:**

1. **일일 운영**
   - 매일 새벽 2시 배치 실행
   - v_batch_processing_monitor로 결과 확인
   - 실패 건수가 있으면 error_messages 확인

2. **예외 처리**
   - 실패한 근로자는 수동 재처리
   - 특수한 경우 수동 판정 후 확인 처리
   - 긴급시 즉시 판정 함수 개별 실행

3. **모니터링**
   - v_daily_worker_insurance_status로 현황 파악
   - v_pending_insurance_actions로 대기 건수 확인
   - 배치 처리 성공률이 95% 이하면 점검 필요

=== 이제 가장 복잡한 일용직 4대보험 관리도 ===
=== 완전 자동화로 정확하게 처리 가능! ===
*/